<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Gitlab CI/CD 小记]]></title>
    <url>%2F2023%2F06%2F29%2Fgitlabci%2F</url>
    <content type="text"><![CDATA[最近项目使用Gitlab CI/CD进行自动化构建的一些记录，所有项目均使用Git Tag触发 Vue项目打包并暂存1234567891011121314151617build-job: stage: build image: node:16 rules: - if: $CI_COMMIT_TAG script: - npm install - npm run build artifacts: name: "$&#123;CI_COMMIT_TAG&#125;" expire_in: 3 days paths: - dist cache: paths: - node_modules/ - dist/ npm安装后打包，在artifacts暂存3天，构建完成后可以在pipeline点击下载，文件名为Git Tag 修改版本号提交1234567891011version-job: stage: version image: node:16 rules: - if: $CI_COMMIT_TAG script: - npm -git-tag-version=false version $CI_COMMIT_TAG - git config --global user.name ci - git config --global user.email ci@email.com - git commit -am "Update verison $CI_COMMIT_TAG" - git push "https://access_token_name:$&#123;CI_PUSH_TOKEN&#125;@gitlab.com/project_name.git" HEAD:$CI_COMMIT_REF_NAME 将package.json中的版本号修改为Git Tag版本号，并提交代码库 这里需要生成gitlab的access token，并且配置到CI/CD的Variables中使用 打包文件上传到测试服务器123456789101112deploy-job: stage: deploy image: node:16 rules: - if: $CI_COMMIT_TAG before_script: - 'which ssh-agent || ( apk update &amp;&amp; apk add openssh-client)' - eval $(ssh-agent -s) - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add - script: - ssh -o StrictHostKeyChecking=no -p 22 user@host "rm -rf xxxx/* &amp;&amp; exit" - scp -o StrictHostKeyChecking=no -P 22 -r dist/* user@host :xxxx/ 安装ssh后，通过ssh删除原有文件，然后scp复制到远程服务器 需要配置ssh key并配置到CI/CD的Variables中使用 Electron打包windows123456789101112131415161718build-job: stage: build image: electronuserland/builder:wine rules: - if: $CI_COMMIT_TAG script: - npm install - npm run build artifacts: name: "$&#123;CI_COMMIT_TAG&#125;" expire_in: 3 days paths: - build cache: paths: - node_modules/ - dist/ - build/ 因为直接构建windows会提示缺少wine，安装起来比较麻烦，可以直接使用镜像electronuserland/builder:wine进行构建 Docker镜像并上传Harbor123456789101112131415build-job: stage: build rules: - if: $CI_COMMIT_TAG image: name: anjia0532/kaniko-project.executor:debug entrypoint: [""] script: - echo "&#123;\"auths\":&#123;\"$HARBOR_URL\":&#123;\"auth\":\"$(echo -n $HARBOR_USERNAME:$HARBOR_PASSWORD | base64)\"&#125;&#125;&#125;" &gt; /kaniko/.docker/config.json - /kaniko/executor --context "$&#123;CI_PROJECT_DIR&#125;" --dockerfile "$&#123;CI_PROJECT_DIR&#125;/Dockerfile" --destination "$&#123;DOCKER_IMAGE_NAME&#125;:$&#123;CI_COMMIT_TAG&#125;" --snapshotMode=redo --use-new-run 借助kaniko，将项目打包成docker镜像后，上传到Harbor镜像仓库 Docker镜像部署k8s1234567891011121314deploy-job: stage: deploy rules: - if: $CI_COMMIT_TAG image: name: bitnami/kubectl:1.27 entrypoint: [""] script: - kubectl config get-contexts - kubectl config use-context $&#123;CONTEXT_NAME&#125; - kubectl config view - kubectl --namespace develop get deployments - kubectl --namespace develop describe deployments/$&#123;DEPLOYMENT_NAME&#125; - kubectl --namespace develop set image deployments/$&#123;DEPLOYMENT_NAME&#125; $&#123;CONTAINER_NAME&#125;=$&#123;DOCKER_IMAGE_NAME&#125;:$&#123;CI_COMMIT_TAG&#125; 借助kubectl，将k8s部署容器替换为最新构建的镜像 To Be Continue]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Gitlab</tag>
        <tag>CI/CD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回顾一下我的2022]]></title>
    <url>%2F2023%2F02%2F03%2Freview-2022%2F</url>
    <content type="text"><![CDATA[持续摆烂ing就…发现我好久没有更新博客了，最初写博客的目的是为了接触新技术时，能够自己记录一遍加深理解。 现在似乎只有日常佛系躺平，emmmm….怎么办呢 那么今年的大事记： 房子装修好了没有入住 基金还没回本 想买车一直没买 健身环救我狗命 俄乌冲突、环台湾军演 新冠疫情管控全面放开，两周感染89% 还是一成不变的社畜生活 今年的flag： 搬出去自己住 等一辆15w的魔豆3 挣大钱 就这样吧]]></content>
      <categories>
        <category>年度总结</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[EMQX搭建对接WSS]]></title>
    <url>%2F2022%2F05%2F26%2Femqx-wss%2F</url>
    <content type="text"><![CDATA[小前端用了这么久WSS，还是头一次自己搭，折腾一下午才弄好，记录一下吧后台服务用的是之前装的‘EMQX’，用于多端的Mqtt通信，这个就不多介绍了，安装方式见‘EMQX下载安装’ WS要用websocket的话比较简单，因为EMQX提供的有ws端口，默认的8083端口，可以通过配置文件修改，改成0.0.0.0:8083，支持外部访问，并且服务器安全组要开放8083端口 这里要提一点就是有时候修改配置文件restart不生效，后台查了一下发现是emqx有个守护进程需要关掉，正确姿势就是先stop，然后ps -aux | grep emq找到守护进程kill掉，再start启动 前端使用的是‘MQTT’ ，因为是老项目，发现最近版本有不兼容的语法，于是找了个使用最多的老版本npm i mqtt@2.18.8 --save 123456789101112131415161718192021import &#123; connect &#125; from 'mqtt'// 建立连接const client = connect('ws://xxx.com:8083/mqtt', &#123; username, password&#125;)// 连接成功后订阅topicclient.on('connect', () =&gt; &#123; client.subscribe(['presence'])&#125;)// 接收消息client.on('message', function (topic, message) &#123; switch (topic) &#123; case 'presence': console.log(message.toString()); break; &#125;&#125;) 本来到这里就以为可以愉快的结束了，部署上线之后才想起来ssl，含泪上WSS WSS我干的第一件事是百度了一下WSS跟https的ssl证书是用同一个，省了点事 跟上面一样，先改下WSS的8084端口，支持外部访问 然后改一下emqx配置文件，把证书配上，因为不知道是哪个所以都改了 123456789101112131415161718192021222324252627## Path to the file containing the user's private PEM-encoded key.#### See: http://erlang.org/doc/man/ssl.html#### Value: Filelistener.ssl.external.keyfile = your certfile.key## Path to a file containing the user certificate.#### See: http://erlang.org/doc/man/ssl.html#### Value: Filelistener.ssl.external.certfile = your certfile.pem## Path to the file containing the user's private PEM-encoded key.#### See: listener.ssl.&lt;name&gt;.keyfile#### Value: Filelistener.wss.external.keyfile = your certfile.key## Path to a file containing the user certificate.#### See: listener.ssl.&lt;name&gt;.certfile#### Value: Filelistener.wss.external.certfile = your certfile.pem 需要确保emqx是有访问权限的 然后是nginx的配置，一种方法是反向代理，如果不想把端口暴露给外部，可以配置一下代理到内部8084端口，我是单独写了个配置文件把wss端口给出来了123456789101112131415161718server &#123; listen 8084 ssl; server_name server.com; ssl_certificate your certfile.pem; ssl_certificate_key your certfile.key; location /mqtt &#123; proxy_redirect off; proxy_pass http://server.com:8084; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection "upgrade"; proxy_connect_timeout 1800s; proxy_send_timeout 1800s; proxy_read_timeout 1800s; &#125;&#125; 前端对接1234567import &#123; connect &#125; from 'mqtt'// 建立连接const client = connect('wss://xxx.com:8084/mqtt', &#123; username, password&#125;) 完结撒花]]></content>
      <categories>
        <category>经验总结</category>
      </categories>
      <tags>
        <tag>EMQX</tag>
        <tag>mqtt</tag>
        <tag>websocket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回顾一下我的2021]]></title>
    <url>%2F2022%2F04%2F20%2Freview-2021%2F</url>
    <content type="text"><![CDATA[为什么一个人可以懒到4月份才开始写上一年的年度总结呢今年已经是工作的第五年了，回忆一下过去一年，似乎并没有什么太大的变化。最初的三年，感觉自己一直处于一个飞速进步的阶段，对技术充满热情，对于未知事物存在很强的求知欲，每天都在朝着更好的方向去努力。反观现在，好像已经没有了最初的动力，不光是技术上，个人工作态度上也进入了瓶颈，有些躺平的意思，今年要努力呢。 反思时间结束，下面是今年的大事记： 5月底交房了，虽然不及预期槽点满满，心里总归还是比较开心的 纪念党的100周年，我们生在国旗下，长在春风里，一起为党庆生 720暴雨，疫情封城，虽然天灾人祸接踵而至，但是还是要给郑州点赞的 开始买基金，目前亏损18%，嗯。。。今年目标是回本 工作方面没啥变化，依旧是每天做着赔钱的项目 今年的flag： 锻炼身体 学好英语 出国旅游 出省旅游 装修入住 攒钱买车 怀抱希望，今年一定会有好运。。。的吧？]]></content>
      <categories>
        <category>年度总结</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[回顾一下我的2020]]></title>
    <url>%2F2021%2F01%2F02%2Freview-2020%2F</url>
    <content type="text"><![CDATA[流光容易把人抛，虽然每年都会说时间过得很快，但我现在回首2020，感觉发生了很多事，又一时想不起来做了什么，不得不再老套的感慨一下，今年过得真快。相比前两年，在个人技能树方面似乎没有太大的进步，没有学到太多的新技术，甚至自己也没有写出什么拿的出手的东西，真是怠惰呢，就不做总结了。 今年的大事记： 突如其来的新冠疫情，打乱了一整年的生活节奏，希望2021没有新冠 5月份的一次感冒，感觉把我身体整个的一个亚健康状态打破了，胸闷、反酸、心率不齐，几个月的时间里不停的往医院跑，中间因为某庸医开的药导致了一段时间的高血压，各种吃药的副作用，最终在一家中医院调理好的。算是为自己敲响警钟吧，以后一定要注意身体 独自一人青海甘肃半自由行，头一次体验拼车游的方式，好评 十几年没住过院了吧，针灸跟拔罐真的疼 交房延期了，装修的钱也没攒够 有小伙伴真好 然后是今年的flag： 锻炼身体 学好英语 出国旅游 装修房子 最后感叹一下我多灾多难的本命年吧，上一个本命年雪灾、地震、金融危机，这一个本命年疫情、火灾。希望新的2021年，山河无恙，人间皆安。]]></content>
      <categories>
        <category>年度总结</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[IOT开源项目Thingsboard开发环境搭建]]></title>
    <url>%2F2020%2F11%2F05%2Fthingsboard%2F</url>
    <content type="text"><![CDATA[Thingsboard社区版本地开发环境搭建，Java小白的不完全攻略，陆续补充 系统环境本机已有的系统环境 MacOS 10.15.6 JDK 1.8 Git 2.24.3 Node 10.16.0 IDEA 安装maven使用HomeBrew安装1brew install maven 代码编译github拉取代码，并切换到最新分支12git clone https://github.com/thingsboard/thingsboard.gitgit checkout release-3.1 maven编译1mvn clean install -DskipTests 时间较长，为了避免yarn安装报错，可以先cd到ui-ngx目录下执行yarn install，等待的同时可以先安装下postgresql 安装postgresql使用HomeBrew安装1brew install postgresql 安装完成后本地创建postgresql数据库，并修改/application/src/main/resources目录下thingsboard.yml文件中的数据库配置123456789101112131415161718# SQL DAO Configurationspring: data: jpa: repositories: enabled: "true" jpa: open-in-view: "false" hibernate: ddl-auto: "none" database-platform: "$&#123;SPRING_JPA_DATABASE_PLATFORM:org.hibernate.dialect.PostgreSQLDialect&#125;" datasource: driverClassName: "$&#123;SPRING_DRIVER_CLASS_NAME:org.postgresql.Driver&#125;" url: "$&#123;SPRING_DATASOURCE_URL:jdbc:postgresql://localhost:5432/thingsboard&#125;" //数据库连接 username: "$&#123;SPRING_DATASOURCE_USERNAME:postgres&#125;" // 用户名 password: "$&#123;SPRING_DATASOURCE_PASSWORD:postgres&#125;" // 密码 hikari: maximumPoolSize: "$&#123;SPRING_DATASOURCE_MAXIMUM_POOL_SIZE:16&#125;" Maven构建使用IDEA打开项目，右键项目根目录下的pom.xml文件，添加为maven项目，之后右键Maven-&gt;Reload project 填充数据项目的数据表sql文件位于/dao/src/main/resources/sql目录下，用户数据填充文件是/dao/src/test/resources/sql目录下的system-data.sql，最初的时候我是手动导入的sql文件，后来发现了正确的打开方式 提供了有一个脚本文件来填充数据，在项目根目录执行以下命令123cd application/target/bin/installchmod a+x install_dev_db.shsudo ./install_dev_db.sh 运行项目找到/application/src/main/java/org.thingsboard.server目录下的ThingsboardServerApplication文件，右键运行即可 运行成功后访问localhost:8080，使用填充的测试用户登录 系统管理员 用户名：sysadmin@thingsboard.org 密码：sysadmin 租户 用户名：tenant@thingsboard.org 密码：tenant 顾客 用户名：customer@thingsboard.org 密码：customer 前端开发命令行进入ui-ngx目录，执行npm run start运行访问localhost:4200即可，需要后台同时运行 目录结构1234567891011application: 应用程序主目录，整体项目打包时也是这个Modulecommon: 公共工具集、方法集模块dao: 数据访问对象集合，整个应用的DAO层，一般只要dao的都要data，以实现不同数据库数据结构兼容。docker: 集群部署-docker容器解决方案，包含了部署环境和shell脚本k8s: 容器编排工具Kubernetes的配置文件和自动化脚本msa: 微服务半自动构建模块，包含了黑盒测试、js执行引擎等netty-mqtt: TB的MQTT协议的实现，包括连接、发布、订阅、遗嘱、关闭等rule-engine: TB的规则引擎，TB没有用开源的Drools等工具，而是自己开发了一套规则引擎，主要包含3个组件和1套服务接口tools: 工具模块，主要实现了MQTT with SSL客户端和REST客户端。可以测试用。transport: 三种消息传输服务启动器，服务的实现参考common/transport,mqtt协议的实现见netty-mqttui: TB的用户界面，主要使用AngularJS和react组件，单页应用（要替换掉，用Vue） To Be Continue]]></content>
      <categories>
        <category>插件工具</category>
        <category>项目实例</category>
      </categories>
      <tags>
        <tag>angular</tag>
        <tag>java</tag>
        <tag>iot</tag>
        <tag>thingsboard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cordova混合开发APP踩坑记录]]></title>
    <url>%2F2020%2F08%2F18%2Fcordova%2F</url>
    <content type="text"><![CDATA[最近一段时间做了两个混合开发APP的项目，分别使用了‘Ionic’和‘Quasar’进行开发，‘Cordova’进行移动应用构建Cordova是一个开发跨平台Web App的工具, 将Web开发项目构建成移动应用，基于浏览器进行开发，同时可以依赖各种Cordova插件进行原生APP的操作，这里就主要写一下用到的一些插件 切换到iOS WkWebViewIonic和Quasar默认使用的都是UIWebView，但是在iOS 12.0中已弃用，在开发时就需要做一下切换，推荐使用cordova-plugin-wkwebview-engine插件1cordova plugin add cordova-plugin-wkwebview-engine 安装完成后在config.xml中platform ios部分添加添加123&lt;platform name=&quot;ios&quot;&gt; &lt;preference name=&quot;WKWebViewOnly&quot; value=&quot;true&quot; /&gt;&lt;/platform&gt; 详见‘https://github.com/apache/cordova-plugin-wkwebview-engine’ 状态栏设置推荐使用cordova-plugin-statusbar，可以对状态栏字体，背景色等作出调整比如iOS状态栏字体默认是黑色的，想要修改成白色，在config.xml添加1&lt;preference name=&quot;StatusBarStyle&quot; value=&quot;lightcontent&quot; /&gt; 详见‘https://github.com/apache/cordova-plugin-statusbar’ 状态栏高度由于不同型号手机状态栏高度不一致，我们有时候需要去获取到状态栏高度，可以使用cordova-plugin-statusbar-height插件详见‘https://github.com/wangjunget/cordova-plugin-statusbar-height’ 启动图推荐使用cordova-plugin-splashscreen，配置启动图和相关设置需要注意加入一下配置，避免安卓启动图显示比例出现问题1&lt;preference name=&quot;SplashMaintainAspectRatio&quot; value=&quot;true&quot; /&gt; 详见‘https://github.com/apache/cordova-plugin-splashscreen’ 需要注意的坑点 iOS启动图名字需要严格按照文档中来，否则不会生效 安卓启动图不能只设置横屏或者竖屏，否则安装包解析会出错 横竖屏Cordova应用默认是可以切换横竖屏显示，如果想要固定一种显示，可以添加配置1234// 固定竖屏&lt;preference name=&quot;Orientation&quot; value=&quot;portrait&quot; /&gt;// 固定横屏&lt;preference name=&quot;Orientation&quot; value=&quot;landscape&quot; /&gt; 如果想要动态的去设置的话，可以安装cordova-plugin-screen-orientation插件来操作1234// 固定横屏screen.orientation.lock(&apos;landscape&apos;);// 取消固定screen.orientation.unlock(); config.xml中的配置和cordova-plugin-screen-orientation是可以结合使用的详见‘https://github.com/apache/cordova-plugin-screen-orientation’ 未完待续]]></content>
      <categories>
        <category>经验总结</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>cordova</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SonarQube简介与Mac快速搭建]]></title>
    <url>%2F2020%2F07%2F02%2Fsonarqube%2F</url>
    <content type="text"><![CDATA[SonarQube是一个开源平台，用于管理代码的质量主要从以下七个维度检测代码质量 不遵循代码标准 sonar可以通过PMD,CheckStyle,Findbugs等等代码规则检测工具规范代码编写。 潜在的缺陷 sonar可以通过PMD,CheckStyle,Findbugs等等代码规则检测工具检 测出潜在的缺陷。 糟糕的复杂度分布 文件、类、方法等，如果复杂度过高将难以改变，这会使得开发人员 难以理解它们, 且如果没有自动化的单元测试，对于程序中的任何组件的改变都将可能导致需要全面的回归测试。 重复率 检查重复的代码块，避免大量的复制粘贴。 注释不足或者过多 没有注释将使代码可读性变差，特别是当不可避免地出现人员变动时，程序的可读性将大幅下降。而过多的注释又会使得开发人员将精力过多地花费在阅读注释上，亦违背初衷。 单元测试覆盖率sonar可以很方便地统计并展示单元测试覆盖率。 糟糕的设计 通过sonar可以找出循环，展示包与包、类与类之间的相互依赖关系，可以检测自定义的架构规则。通过sonar可以管理第三方的jar包，可以利用LCOM4检测单个任务规则的应用情况， 检测藕合。 Docker快速安装使用安装包还需要安装并配置数据库环境，而且SonarQube 8.0以上版本是不支持mysql的，所以选择使用Docker快速安装1docker pull sonarqube 镜像安装完成后，命名并在9000端口启动1docker run -d --name sonarqube -p 9000:9000 sonarqube 9000是默认端口，其他端口启动的话在使用SonarScanner时需要修改配置文件 访问9000端口查看是否启动成功，首次启动成功后，后续使用时1234// 启动docker start sonarqube// 关闭docker stop sonarqube 安装SonarScannerSonarScanner用于扫描项目代码，安装比较简单，官网下载安装包解压即可，‘点击安装’ 一般不需要修改配置，要修改比如默认端口号之类的配置的话，编辑conf/sonar-scanner.properties，按官网说明修改即可。 解压完成后，需要配置环境变量12export SONAR_RUNNER_HOME=/your path/SonarQube/sonar-scannerexport PATH=$PATH:$SONAR_RUNNER_HOME/bin 项目配置扫描项目代码时需要在代码根目录下创建sonar-project.properties文件，具体见官网，下面简单介绍一下我用到的几个123456789101112131415161718# 项目ID，唯一sonar.projectKey=siemens# 平台显示的项目名sonar.projectName=siemens# 版本号sonar.projectVersion=1.0# 路径sonar.sources=./# 编程语言sonar.language=js,ts# 编码sonar.sourceEncoding=UTF-8# 测试覆盖率排除的文件sonar.coverage.exclusions=**/*.spec.ts# 代码扫描排除的文件sonar.exclusions=**/*.spec.ts,**/*.scss,e2e/**/*.*# 测试报告路径sonar.typescript.lcov.reportPaths=coverage/lcov.info 配置好之后在项目根目录执行1sonar-scanner 成功后访问9000端口查看报告即可]]></content>
      <categories>
        <category>插件工具</category>
      </categories>
      <tags>
        <tag>sonarqube</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Otter数据同步简介]]></title>
    <url>%2F2020%2F03%2F29%2Fotter%2F</url>
    <content type="text"><![CDATA[Otter是阿里巴巴开源的增量数据同步工具，因为项目用到了，简单记录一下 简介定位：基于数据库增量日志解析，准实时同步到本机房或异地机房的mysql/oracle数据库. 一个分布式数据库同步系统项目地址：‘https://github.com/alibaba/otter’ 工作原理 通过‘Canal’做数据库增量订阅，获取增量数据 Web管理系统manager进行同步配置，推送到node节点 node节点将同步状态反馈到manager上 基于zookeeper，解决分布式状态调度的，允许多node节点之间协同工作 所以在建立数据同步时，需要满足的条件是： 搭建manager管理平台 数据源需要配置canal，如果是双向同步，两边都需要配置canal 位于同一个zookeeper集群 至少一个node节点 环境安装 Docker安装模式详见官方文档‘Docker_QuickStart’ 手工安装模式详见官方文档‘Manager_Quickstart’ ‘Node_Quickstart’ 配置流程通过manager平台来创建数据同步服务，流程如下 创建zookeeper 创建node 添加数据库配置 添加数据同步表配置 创建canalcanal对应一个数据源，每一个数据同步任务都需要至少一个canal，不能重复使用 创建channel 创建pipelinechannel下具体的数据同步任务，需要选择node和canal 设置pipeline的数据同步映射规则定义源数据表和目标数据表的同步关系 启动channel]]></content>
      <categories>
        <category>经验总结</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>otter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云RDS快速上手]]></title>
    <url>%2F2020%2F03%2F28%2Frds%2F</url>
    <content type="text"><![CDATA[介绍一下如何创建阿里云RDS实例、进行基本设置以及连接实例数据库 简介阿里云关系型数据库（Relational Database Service，简称 RDS）是一种稳定可靠、可弹性伸缩的在线数据库服务。基于阿里云分布式文件系统和高性能存储，RDS 支持 MySQL、SQL Server、PostgreSQL 和 PPAS（Postgre Plus Advanced Server，一种高度兼容 Oracle 的数据库）引擎，并且提供了容灾、备份、恢复、监控、迁移等方面的全套解决方案，彻底解决数据库运维的烦恼 太长不看：其实就是个独立的、可直接访问的云数据库 创建实例购买流程不多介绍，说一下需要注意的几个点 地域实例所在的地理位置，购买后将无法更换地域，只能在同一地域迁移可用区，需要确保RDS实例与需要连接的RES实例在同一个地域，否则无法发挥最佳性能 数据库类型选择合适的数据库类型：MySQL、SQL Server、PostgreSQL和PPAS，以及对应的版本，如MySQL5.5、5.6、5.7、8.0，不同地域所支持的数据库不同 存储空间RDS的存储空间包括数据空间、系统文件空间、Binlog文件空间和事务文件空间。我在导入数据后发现有额外占用了3G左右的存储空间，所以在购买时需要注意除了本身的数据外，留出足够的空间 设置白名单RDS实例默认的白名单只包含默认IP地址127.0.0.1，表示任何设备均无法访问该RDS实例设置白名单包括两种操作： 设置IP名单添加IP地址，使这些IP地址可以访问该RDS实例 设置ECS安全组添加ECS安全组，使ECS安全组内的ECS实例可以访问该RDS实例，只有部分版本和地域支持 若将白名单设置为%或者0.0.0.0/0，表示允许任何IP地址访问该RDS实例，建议只有本地调试时使用，上线后不要这么做 访问地址可以在RDS实例控制台-&gt;基本信息中查看 内网访问默认开放内网地址，也是推荐使用的地址，只有ECS和DMS可以通过内网访问RDS，并且需要满足以下条件 ECS和RDS属于同一个阿里云主账号。 ECS和RDS位于同一个地域。 ECS和RDS的网络类型相同。 如果ECS和RDS网络类型都是VPC，则必须处于同一个VPC。 ECS的私网IP已添加到RDS白名单 公网访问公网也叫外网，通过公网访问RDS就是使用RDS实例的外网地址进行访问。RDS实例默认不提供外网地址，如果要通过公网访问，需要在数据库连接页面申请外网地址 创建账号和数据库RDS for MySQL实例支持两种数据库账号 高权限账号一个实例中只能创建一个高权限账号，可以管理所有普通账号和数据库 普通账号一个实例可以创建多个普通账号，需要手动给普通账号授予特定数据库的权限 连接数据库不再赘述，通过内网/外网地址，使用创建好的账号登录即可]]></content>
      <categories>
        <category>经验总结</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>rds</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql优化：Explain分析介绍]]></title>
    <url>%2F2020%2F01%2F22%2Fexplain%2F</url>
    <content type="text"><![CDATA[使用Explain命令可以查看SQL语句对于查询和连接表的执行效果，帮助我们选择更好的索引，完成查询的优化使用方法，在SQL语句前加上explain就可以了例如：explain select * from users得到的结果类似： id select_type table partitions type possible_keys key key_len ref rows filtered Extra 1 SIMPLE users NULL ALL NULL NULL NULL NULL 39484 100.00 NULL 下面具体介绍下每一项的含义 idSELECT识别符。这是SELECT的查询序列号 select_typeSELECT类型,可以为以下任何一种: SIMPLE: 简单SELECT(不使用UNION或子查询) PRIMARY: 最外面的SELECT UNION: UNION中的第二个或后面的SELECT语句 DEPENDENT UNION: UNION中的第二个或后面的SELECT语句,取决于外面的查询 UNION RESULT: UNION 的结果 SUBQUERY: 子查询中的第一个SELECT DEPENDENT SUBQUERY: 子查询中的第一个SELECT,取决于外面的查询 DERIVED: 导出表的SELECT(FROM子句的子查询) table输出的行所引用的表 type联接类型。下面给出各种联接类型,按照从最佳类型到最坏类型进行排序: system: 表仅有一行(=系统表)。这是const联接类型的一个特例。 const: 表最多有一个匹配行,它将在查询开始时被读取。因为仅有一行,在这行的列值可被优化器剩余部分认为是常数。const表很快,因为它们只读取一次! eq_ref: 对于每个来自于前面的表的行组合,从该表中读取一行。这可能是最好的联接类型,除了const类型。 ref: 对于每个来自于前面的表的行组合,所有有匹配索引值的行将从这张表中读取。 ref_or_null: 该联接类型如同ref,但是添加了MySQL可以专门搜索包含NULL值的行。 index_merge: 该联接类型表示使用了索引合并优化方法。 unique_subquery: 该类型替换了下面形式的IN子查询的ref: value IN (SELECT primary_key FROM single_table WHERE some_expr) unique_subquery是一个索引查找函数,可以完全替换子查询,效率更高。 index_subquery: 该联接类型类似于unique_subquery。可以替换IN子查询,但只适合下列形式的子查询中的非唯一索引: value IN (SELECT key_column FROM single_table WHERE some_expr) range: 只检索给定范围的行,使用一个索引来选择行。 index: 该联接类型与ALL相同,除了只有索引树被扫描。这通常比ALL快,因为索引文件通常比数据文件小。 ALL: 对于每个来自于先前的表的行组合,进行完整的表扫描。 possible_keys指出MySQL能使用哪个索引在该表中找到行 key显示MySQL实际决定使用的键(索引)。如果没有选择索引,键是NULL。 key_len显示MySQL决定使用的键长度。如果键是NULL,则长度为NULL。 ref显示使用哪个列或常数与key一起从表中选择行。 rows显示MySQL认为它执行查询时必须检查的行数。多行之间的数据相乘可以估算要处理的行数。 filtered显示了通过条件过滤出的行数的百分比估计值。 Extra该列包含MySQL解决查询的详细信息 Distinct:MySQL发现第1个匹配行后,停止为当前的行组合搜索更多的行。 Not exists:MySQL能够对查询进行LEFT JOIN优化,发现1个匹配LEFT JOIN标准的行后,不再为前面的的行组合在该表内检查更多的行。 range checked for each record (index map: #):MySQL没有发现好的可以使用的索引,但发现如果来自前面的表的列值已知,可能部分索引可以使用。 Using filesort:MySQL需要额外的一次传递,以找出如何按排序顺序检索行。 Using index:从只使用索引树中的信息而不需要进一步搜索读取实际的行来检索表中的列信息。 Using temporary:为了解决查询,MySQL需要创建一个临时表来容纳结果。 Using where:WHERE 子句用于限制哪一个行匹配下一个表或发送到客户。 Using sort_union(…), Using union(…), Using intersect(…):这些函数说明如何为index_merge联接类型合并索引扫描。 Using index for group-by:类似于访问表的Using index方式,Using index for group-by表示MySQL发现了一个索引,可以用来查 询GROUP BY或DISTINCT查询的所有列,而不要额外搜索硬盘访问实际的表。]]></content>
      <categories>
        <category>经验总结</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[插件:DragMap]]></title>
    <url>%2F2020%2F01%2F15%2Fdrag-map%2F</url>
    <content type="text"><![CDATA[最近做的一个拖拽定位工具类，主要应用场景为各种IOT项目的示意图，设备定位功能目前分为两种模式 Canvas：地图由Canvas绘制，支持拖拽和缩放，包含位点数据的管理和一系列配置方法，相比定位版，使用起来更加方便，功能更加齐全，推荐使用 定位：绝对定位版本，比较简易，主要提供了拖拽方法，事件发送和位点绝对定位数据的转换，不包含对dom结构和数据的管理，作者已放弃治疗，请慎用 GitHub仓库地址: ‘https://github.com/gitliyu/drag-map’ DemoDemo: ‘https://www.liyu.fun/demo/drag-map’ Demo源码示例： ‘Canvas’ ‘定位’ 安装1npm install drag-map 使用123import DragMap from 'drag-map'const dragMap = new DragMap(); Canvas版本默认html结构如下，可在配置项中修改1234567&lt;div id="drag-list"&gt; &lt;div class="drag-target"&gt;1&lt;/div&gt; &lt;div class="drag-target"&gt;2&lt;/div&gt; &lt;div class="drag-target"&gt;3&lt;/div&gt;&lt;/div&gt;&lt;canvas id="drag-map"&gt;&lt;/canvas&gt; 配置项在实例化时可接受参数，除type和options外均为非必填项，以下为默认值1234567891011121314151617new DragMap(&#123; document, // 文档对象注入 type: 'canvas', // 使用canvas版本时必须设置 list: '#drag-list', // 可选目标列表 map: '#drag-map', // 拖拽目标区域 target: '.drag-target', // 拖拽目标 options: &#123;&#125;, // 可选区域的数据列表 data: [], // 初始化的数据 bgImage: 'bg.png', // 背景图片地址 maxScale: 3, // 最大放大倍数，默认为3 minScale: 1, // 最小缩放倍数，默认为1 scaleStep: 0.05, // 鼠标滑轮每次缩放比例, 默认为0.05 readonly: false, // 只读模式 deleteImage: 'close.png', // 删除按钮图片地址 deleteImageSize: 20, // 删除按钮尺寸，默认为20px labelStyle: &#123;&#125; // 位点标签样式&#125;) 其中options为拖拽位点图片数据，格式如下1234567&#123; key: 1, // key值必须设置，作为唯一标识符，与drag-list索引值对应 url: 'xxx.png', // 位点图片地址 label: 'label', // 位点标签 disabled: false, // 选项禁用 ...options // 其他自定义数据，会在事件和记录的位点数据中一并记录&#125; 位点数据data格式如下12345678[&#123; key: 1, x: 0.2, // 横坐标 保留4位 y: 0.3, // 纵坐标 width: 70, // 位点图像宽度 height: 70, // 位点图像高度 ...options // options中自定义数据&#125;] 位点标签样式labelStyle格式如下123456&#123; font: '16px bold 黑体', // 字体样式字符串 fillStyle: '#333', // 字体颜色 margin: 15, // label间距，默认15 position: 'bottom' // label位置，默认bottom top|bottom|left|right&#125; 事件对于拖拽各个过程的数据，都会以事件的形式发送出来，监听方式如下12345678const dragMap = new DragMap();dragMap.on('drop', (data, event) =&gt; &#123; console.log('drop', data, event);&#125;);dragMap.on('click', data =&gt; &#123; console.log('click', data);&#125;) 以下是所有事件介绍 dragstart(data, event) 拖拽开始 dragenter(data, event) 进入目标区域 dragover(data, event) 在目标区域中拖拽 drop(data, event) 拖拽完成 dragleave(data, event) 拖拽离开目标区域 click(data, event) 点击位点图像 delete(data) 点击位点删除按钮 mouseover(data, event) 鼠标经过位点 mouseleave(data, event) 鼠标移出位点 事件接受参数event为原生事件参数，data为当前位点数据格式同实力化格式一致 方法操作类 refresh() 当dom元素发生变化后调用，重新刷新dom节点并绑定事件 draw() 重绘画布 clear() 清空数据并重置画布，保留背景图 数据类 setOptions(options) 设置可选项数据，返回Promise，设置后需要等待图片加载完成再进行下一步 123dragMap.setOptions(options).then(() =&gt; &#123; // do something&#125;) setData(data) 设置位点数据 getData() 获取位点数据 配置类 setBgImage(url) 设置背景图 setScale(scale) 设置当前缩放倍数 setMinScale(scale) 设置最小缩放倍数，默认1 setMaxScale(scale) 设置最大缩放倍数，默认3 setScaleStep(step) 设置每次缩放比例，默认0.05 setImageSize(width, height) 设置位点图片大小，默认为图片本身大小,height不传时默认和width相同 12dragMap.setImageSize(70)dragMap.setImageSize(50, 60) setDeleteImage(url) 设置删除按钮图片 setDeleteImageSize(size) 设置删除按钮尺寸 setOptionDisabled(index, disabled) 设置选项禁用 12dragMap.setOptionDisabled(1) // 索引为1的禁用dragMap.setOptionDisabled(2, false) // 取消禁用 setLabelStyle(style) 设置label样式 123456dragMap.setLabelStyle(&#123; font: '16px bold 黑体', fillStyle: '#333', margin: 15, position: 'bottom'&#125;) 定位版本默认html结构为1234567&lt;div id="drag-list"&gt; &lt;div class="drag-target"&gt;1&lt;/div&gt; &lt;div class="drag-target"&gt;2&lt;/div&gt; &lt;div class="drag-target"&gt;3&lt;/div&gt;&lt;/div&gt;&lt;div id="drag-map"&gt;&lt;/div&gt; 配置项在实例化时可接受参数，以下为默认值123456new DragMap(&#123; document, // 文档对象注入 list: '#drag-list', // 可选目标列表 map: '#drag-map', // 拖拽目标区域 target: '.drag-target' // 拖拽目标&#125;) 事件 dragstart(data, event) 拖拽开始 dragenter(data, event) 进入目标区域 dragover(data, event) 在目标区域中拖拽 drop(data, event) 拖拽完成 dragleave(data, event) 拖拽离开目标区域 移动端只支持drop事件 相比于canvas版本，data数据格式有所不同12345678910&#123; action: 'add' // 操作类型 'add'|'edit' index: 1 // 拖拽对象索引值 offsetX: 155 // 水平偏移量，单位px offsetY: 106 // 垂直偏移量，单位px percentX: 10.18 // 水平偏移百分比 percentY: 27.04 // 垂直偏移百分比 style: 'left: 155px;top: 106px;', // style字符串 percentStyle: 'left: 10.18%;top: 27.04%;' // 百分比style字符串&#125; 方法 refresh() 当dom元素发生变化后调用，重新刷新dom节点并绑定事件]]></content>
      <categories>
        <category>插件工具</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从无到有搭建Superset(Mac)]]></title>
    <url>%2F2020%2F01%2F04%2Fsuperset%2F</url>
    <content type="text"><![CDATA[‘Superset’是一款由Airbnb开源的“现代化的企业级 BI（商业智能） Web 应用程序”，其通过创建和分享dashboard，为数据分析提供了轻量级的数据查询和可视化方案。 Superset简介 Superset的前端主要用到了React和NVD3/D3，而后端则基于Python的Flask框架和Pandas、SQLAlchemy等依赖库，主要提供了这几方面的功能： 集成数据查询功能，支持多种数据库，包括 MySQL、PostgresSQL、Oracle、SQL Server、SQLite、SparkSQL 等，并深度支持 Druid。 通过 NVD3/D3 预定义了多种可视化图表，满足大部分的数据展示功能。如果还有其他需求，也可以自开发更多的图表类型，或者嵌入其他的 JavaScript 图表库（如 HighCharts、ECharts）。 提供细粒度安全模型，可以在功能层面和数据层面进行访问控制。支持多种鉴权方式（如数据库、OpenID、LDAP、OAuth、REMOTE_USER 等）。 依赖安装Python由于我本地没有安装Python，所有首先用Homebrew安装下Python3.71brew install python3 之后需要配置环境变量，按步骤执行以下操作12345678# 编辑bash_profile文件vim ~/.bash_profile# 末尾添加一行，指向本地安装路径alias python=/usr/local/bin/python3.7# 环境变量生效source .bash_profile# 查看python版本python -v AnacondaSuperset的依赖包较多，为了避免冲突，需要先搭建虚拟环境，再进行安装，网上查找到的教程基本上都是推荐使用Anaconda自带的conda工具创建虚拟环境，安装方式可以查看‘mac下anaconda的安装及简单使用’安装配置完成后开始创建虚拟环境1conda create -n superset python=3.7 创建完成后启动1activate superset Superset安装首先需要安装Python包管理工具pip1sudo easy_install pip 之后安装superset，推荐使用豆瓣源1pip install superset -i https://pypi.douban.com/simple 初始化并启动1234567891011121314# 创建管理员账号fabmanager create-admin --app superset # 初始化数据库superset db upgrade# 载入案例数据superset load_examples# 初始化角色和权限superset init# 启动服务superset run -p 8088 关于启动命令，我找到的教程都是使用superset runserver，但我实测时发现使用run命令才能启动，应该是版本不一致导致的 未完待续]]></content>
      <categories>
        <category>经验总结</category>
      </categories>
      <tags>
        <tag>superset</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回顾一下我的2019]]></title>
    <url>%2F2020%2F01%2F01%2Freview-2019%2F</url>
    <content type="text"><![CDATA[不知不觉又一年，终于到了全国人民心心念念的全面小康了，很庆幸自己没有作为贫困人口被消灭掉&emsp;&emsp;首先说一下工作方面的吧，这一年感觉自己的技能树都有些点歪了，我本人还是希望能够在前端领域更深入一些，但是也是做外包的无奈吧，感觉横向发展更多一些&emsp;&emsp;一句话总结，去年的话主要是完成了前端到全栈开发的一个转变，后端的工作比较多，今年的话，感觉是从单纯的开发，到目前更侧重于架构和项目管理吧，工作面也变得更加广泛。虽然自己觉得步子大了些，好在也还在我的承受范围内。回忆下今年的发生的值得纪念的事 做了一年多的项目（18年12月）终于上线并且稳定使用了，和客户签下了长期的维护合同，并且陆续又有相关的新项目，有种苦日子熬出头的感觉 参与了某世界一百强合作项目，感觉在继鹅厂之后心中对于所谓大公司水平的评价又下了一层 由于老电脑不堪重负光荣退休，终于一咬牙买了台Mac，仿佛打开了新世界的大门，后悔自己没有早点买 第一次准备项目报价，不出意外的因为经验不足对项目的成本估计有误，还好也不算凉透，目前还在抢救中 当上了项目经理，才知道项目规划是真难顶啊，我这个人管自己都嫌累还要管别人，而且本身不擅长跟客户打交道，磕磕绊绊的进行中，希望接下来项目顺利吧 &emsp;&emsp;然后是一些技术相关的 Vue: 看了看源码，写了些总结，整了几个插件，做了次分享，之后坐等3.0 Angular + Ionic: 跟项目做了一款混合开发的APP，个人感觉Angular真是不好用，Ionic做混合性能也很差，不说跟原生相比，跟React Native都有一段差距 Redis: 接触了之后感觉应用场景蛮多的，项目中都有用到，可以用来做数据缓存，并发处理，排名和队列等等 Mqtt: 几个物联网项目都有用到，应该算是目前比较常用的通信方式了，可用性挺强的 Laravel: 不得不说Laravel挺好用的，但是方法是真繁杂啊，感觉比接触过的所有前端框架都复杂，想熟悉的话挺费时间的 其他的就不一一列出来了，今年的收获还是挺多的 &emsp;&emsp;然后是个人生活方面，感觉又是平平淡淡的一年吧，没有什么大的变化，看了看自己去年年初立下的flag，似乎没有一个目标说的是完成了的，感慨万分，但是今年的flag还是要立的，万一实现了呢 掌握一门新的编程语言 了解更多云服务器相关的知识 今年10月就要交房了，攒够装修的钱吧 出国旅游 &emsp;&emsp;最后，今年到了自己本命年了，希望新的一年能够有更多的好运吧 先从年会中奖开始吧，没中的话我再来把这句话删掉(抽到了一套比较精致的餐具四件套，虽然说没有中大奖，但是还是高于期望值的，就不删了)]]></content>
      <categories>
        <category>年度总结</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MAMP配置PHP环境的一些问题]]></title>
    <url>%2F2019%2F08%2F07%2Fmamp%2F</url>
    <content type="text"><![CDATA[踩坑实录 切换默认PHP版本由于Mac自带PHP环境，在使用MAMP切换版本后全局PHP版本并不会生效（Apache使用的PHP版本会生效），那么如果想要PHP版本的话，使用以下步骤来设置： 终端输入，编辑或创建bash_profile文件 1sudo vim ~/.bash_profile 将以下代码添加到bash_profile脚本里，路径指向PHP安装路径的bin目录 1export PATH=&quot;/Applications/MAMP/bin/php/phpxxx/bin:$PATH&quot; 执行文件，使其生效 1source .bash_profile php artisan 相关命令没有效果且没有错误提示默认设置下命令行中的php禁用了错误提示。于是搜索后找到了办法，很简单，只需为php创建一个别名：1alias php=&quot;php -d display_errors&quot; 切换MAMP中的php老版本MAMP比较坑的一点就是虽然提供了很多php版本来使用，但是只有在付费版的MAMP Pro才可以进行切换，免费版只允许切换最新的两个版本后来了解到，它是根据文件夹来获取的版本，于是想到，找到/Applications/MAMP/bin/php目录，将不需要的php文件夹改个名字就好了，比如我想要使用版本为7.0.33，就可以这样设置就可以选择自己想要的版本了]]></content>
      <categories>
        <category>经验总结</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis常用命令及数据结构介绍]]></title>
    <url>%2F2019%2F05%2F16%2Fredis%2F</url>
    <content type="text"><![CDATA[Redis是一个使用ANSI C编写的开源、支持网络、基于内存、可选持久性的键值对存储数据库，常用于数据缓存，排行，消息队列等功能 常用命令 命令 说明 时间复杂度 keys [pattern] 遍历所有key O(N) dbsize 查询存储数量 O(1) exists 检查key是否存在 O(1) del key 删除指定的key-value O(1) expire key seconds key在seconds秒后过期 O(1) ttl key 查看key剩余的过期时间 O(1) persist key 去掉key的过期时间 O(1) type key 返回key的类型 O(1) rename key newKey 修改key的名称 O(1) flushall 清空所有数据 O(1) 演示123456789101112131415161718192021222324252627282930➜ redis-cli127.0.0.1:6379&gt; set msg1 helloOK127.0.0.1:6379&gt; set msg2 worldOK127.0.0.1:6379&gt; keys msg*1) &quot;msg1&quot;2) &quot;msg2&quot;127.0.0.1:6379&gt; del msg2(integer) 1127.0.0.1:6379&gt; keys msg*1) &quot;msg1&quot;127.0.0.1:6379&gt; dbsize(integer) 1127.0.0.1:6379&gt; exists msg1(integer) 1127.0.0.1:6379&gt; expire msg1 60(integer) 1127.0.0.1:6379&gt; ttl msg1(integer) 55127.0.0.1:6379&gt; persist msg1(integer) 1127.0.0.1:6379&gt; ttl msg1(integer) -1127.0.0.1:6379&gt; type msg1string127.0.0.1:6379&gt; flushallOK127.0.0.1:6379&gt; keys *(empty list or set) 数据结构如上图所示，Redis虽然是键值对存储数据库，但是不仅仅是简单的key-value格式，它的数据结构分为String(字符串), Hash(字典), List(列表), Set(集合), ZSet(有序集合)五种，下面分别介绍一下 StringString是最常用的key-value格式，内容可以是字符串（json字符串)，数字，以及二进制API 命令 说明 时间复杂度 get key 获取key对应的value O(1) set key value 设置key value O(1) del key 删除key-value O(1) incr key自增1， 如果key不存在，自增后get(key) = 1 O(1) decr key自减1， 如果key不存在，自增后get(key) = -1 O(1) incrby key k key自增k， 如果key不存在，自增后get(key) = k O(1) decr key k key自减k， 如果key不存在，自增后get(key) = -k O(1) setnx key value key不存在，才设置 O(1) set key value xx key存在，才设置 O(1) mget key1 key2 key3 批量获取key，原子操作 O(N) mset key1 value1 key2 value2 批量设置key-value O(1) getset key newvalue set key newvalue并返回旧的value O(1) append key value 将value追加到旧的value O(1) strlen key 返回字符串的长度（注意中文，utf8下一个中文占用3个字符） O(1) incrbyfloat key 3.5 增加key对应的值3.5 O(1) getrange key start end 获取字符串指定下标所有的值 O(1) setrange key index value 设置指定下标所有对应的值 O(1) 演示1234567891011121314151617181920212223242526➜ redis-cli127.0.0.1:6379&gt; set msg helloOK127.0.0.1:6379&gt; get msg&quot;hello&quot;127.0.0.1:6379&gt; incr number(integer) 1127.0.0.1:6379&gt; get number&quot;1&quot;127.0.0.1:6379&gt; incrby number 10(integer) 11127.0.0.1:6379&gt; setnx msg test(integer) 0127.0.0.1:6379&gt; set number 20 xxOK127.0.0.1:6379&gt; get number&quot;20&quot;127.0.0.1:6379&gt; append msg world(integer) 10127.0.0.1:6379&gt; get msg&quot;helloworld&quot;127.0.0.1:6379&gt; strlen msg(integer) 10127.0.0.1:6379&gt; mget msg number1) &quot;helloworld&quot;2) &quot;20&quot; Hash哈希键值结构区别于String的key-value格式，使用了key-filed-value的形式，如下图API 命令 说明 时间复杂度 hset key field 设置hash key对应field的value O(1) hget key field 获取hash key对应field的value O(1) hdel key field 获取hash key对应field的value O(1) hexists key field 判断hash key 是否有field O(1) hlen key 获取hash key field的数量 O(1) hmget key field1 field2…fieldN 批量获取hash key的一批field对应的值 O(N) hset key field1 value1 …fieldN valueN 批量设置hash key的一批field value O(1) hgetall key 返回hash key对应所有的field和value O(N) hvals key 返回hash key对应所有的field的value O(N) hkeys key 返回hash key对应所有的field O(N) hsetnx key field value 设置has key 对应的field的value(如果field已经存在，则失败） O(1) hincrby key field intCounter hash key对应的field的value自增intCounter O(1) hincrbyfloat key field floatCounter 浮点数版本hincrby O(1) 演示123456789101112131415161718192021222324252627➜ redis-cli127.0.0.1:6379&gt; hset user name liyu(integer) 1127.0.0.1:6379&gt; hset user age 23(integer) 1127.0.0.1:6379&gt; hget user name&quot;liyu&quot;127.0.0.1:6379&gt; hexists user gender(integer) 0127.0.0.1:6379&gt; hexists user name(integer) 1127.0.0.1:6379&gt; hlen user(integer) 2127.0.0.1:6379&gt; hmget user name age1) &quot;liyu&quot;2) &quot;23&quot;127.0.0.1:6379&gt; hgetall user1) &quot;name&quot;2) &quot;liyu&quot;3) &quot;age&quot;4) &quot;23&quot;127.0.0.1:6379&gt; hincrby user age 1(integer) 24127.0.0.1:6379&gt; hincrbyfloat user age 1.5&quot;25.5&quot;127.0.0.1:6379&gt; hdel user age(integer) 0 ListList是一个有序的列表结构，内容可重复，可以从两侧或者中间的任意位置插入，常用于队列功能API 命令 说明 时间复杂度 lpush key value1,value2..valueN 从列表左侧插入value O(1-N) Rpush key value1,value2..valueN 从列表右侧插入value O(1-N) linsert key before/after value newValue 在列表指定value前/后插入newValue O(N) lpop key 删除并返回列表左侧第一个子项 O(1) rpop key 删除并返回列表右侧第一个子项 O(1) lrem key count value (1) count&gt;0,从左到右删除count个和value相同的子项 (2) count&lt;0,从右到左删除 (3) count=0,删除所有 O(N) ltrim key start end 按索引范围修剪列表，不在范围内的子项将被删除 O(N) lrange key start end 获取所有范围内所有子项，不会修改列表 O(N) lindex key index 获取列表指定索引的子项 O(1) llen key 获取列表长度 O(1) lset key index newValue 设置列表指定索引值为newValue O(N) blpop key timeout lpop阻塞版本,如果列表没有子项会阻塞列表直到等待超时(timeout)或发现元素为止 O(1) brpop key timeout rpop阻塞版本 O(1) 演示1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950➜ redis-cli127.0.0.1:6379&gt; lpush list a b c d(integer) 4127.0.0.1:6379&gt; rpush list e f g h(integer) 8127.0.0.1:6379&gt; lrange list 0 -11) &quot;d&quot;2) &quot;c&quot;3) &quot;b&quot;4) &quot;a&quot;5) &quot;e&quot;6) &quot;f&quot;7) &quot;g&quot;8) &quot;h&quot;127.0.0.1:6379&gt; lpop list&quot;d&quot;127.0.0.1:6379&gt; rpop list&quot;h&quot;127.0.0.1:6379&gt; linsert list after a b(integer) 7127.0.0.1:6379&gt; lrange list 0 -11) &quot;c&quot;2) &quot;b&quot;3) &quot;a&quot;4) &quot;b&quot;5) &quot;e&quot;6) &quot;f&quot;7) &quot;g&quot;127.0.0.1:6379&gt; lindex list 5&quot;f&quot;127.0.0.1:6379&gt; lrem list 0 a(integer) 1127.0.0.1:6379&gt; llen list(integer) 6127.0.0.1:6379&gt; ltrim list 1 5OK127.0.0.1:6379&gt; lrange list 0 -11) &quot;b&quot;2) &quot;b&quot;3) &quot;e&quot;4) &quot;f&quot;5) &quot;g&quot;127.0.0.1:6379&gt; lset list 1 aOK127.0.0.1:6379&gt; lrange list 0 -11) &quot;b&quot;2) &quot;a&quot;3) &quot;e&quot;4) &quot;f&quot;5) &quot;g&quot; SetSet是一个string类型的无序集合，并且集合成员是唯一的不可重复的数据，包含集合间的操作，常用于数据唯一处理，得到交集等功能API集合内的操作： 命令 说明 时间复杂度 sadd key value1,value2…valueN 向集合key添加value(如果value已经存在，添加失败） O(1) srem key value1,value2…valueN 将集合key中的value移除掉 O(1) scard key 计算集合大小 O(1) sismember key value 判断value 是否在集合中 O(1) srandmember key count 从集合中随机挑count个元素 O(1) spop key count 从集合中随机删除并返回count个元素 O(1) smembers key 获取集合所有元素 O(1) srem key value 将集合key中的value移除掉 O(1) 集合间的操作: 命令 说明 时间复杂度 sdiff key1 key2 差集 O(1) sinter key1 key2 交集 O(1) sunion key1 key2 并集 O(1) sidff/sinter/suion + store destkey 将差集、交集、并集保存在destkey中 O(1) 演示12345678910111213141516171819202122232425262728293031323334➜ redis-cli127.0.0.1:6379&gt; sadd set a b c d(integer) 4127.0.0.1:6379&gt; srem set b(integer) 1127.0.0.1:6379&gt; scard set(integer) 3127.0.0.1:6379&gt; sismember set a(integer) 1127.0.0.1:6379&gt; srandmember set 21) &quot;a&quot;2) &quot;c&quot;127.0.0.1:6379&gt; spop set 11) &quot;c&quot;127.0.0.1:6379&gt; smembers set1) &quot;a&quot;2) &quot;d&quot;127.0.0.1:6379&gt; srem set a(integer) 1127.0.0.1:6379&gt; sadd set b c(integer) 2127.0.0.1:6379&gt; sadd set2 c d e f(integer) 4127.0.0.1:6379&gt; sdiff set set21) &quot;b&quot;127.0.0.1:6379&gt; sinter set set21) &quot;c&quot;2) &quot;d&quot;127.0.0.1:6379&gt; sunion set set21) &quot;b&quot;2) &quot;f&quot;3) &quot;d&quot;4) &quot;c&quot;5) &quot;e&quot; ZSet有序集合ZSet和集合一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数,通过分数来为集合中的成员进行从小到大的排序,有序集合的成员是唯一的,但分数(score)却可以重复，常用于排名功能API 命令 说明 时间复杂度 zadd key score value 添加score和value O(logN) zrem key value1,value2…valueN 将集合中的value移除掉 O(1) zscore key value 返回元素的分数 O(1) zincrby key increScore value 增加或减少元素的分数 O(1) zcard key 返回元素的总个数 O(1) zrank(zrevrank) key member 返回元素的排名 O(1) zrange(zrevrank) key start end [WITHSCORES] 返回指定索引范围内的升序元素[分值] O(logN + m) zrangebyscore(zrevrangebyscore) key minScore maxScore 返回指定分数范围内的升序元素 O(logN + m) zcount key minScore maxScore 返回有序集合内在指定分数范围内的个数 O(logN + m) zremrangebyrank key start end 删除指定排名内的升序元素 O(logN + m) zremrangebyscore key minScore maxScore 删除指定分数内的升序元素 O(logN + m) zintersti=ore destination numkeys(表示key的个数) key [key …] 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中 zunionstore destination numkeys key [key …] 计算给定的一个或多个有序集的并集，并存储在新的 key 中 未完待续]]></content>
      <categories>
        <category>插件工具</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Crontab定时任务]]></title>
    <url>%2F2019%2F05%2F15%2Fcrontab%2F</url>
    <content type="text"><![CDATA[Linux系统的crontab是用来定期执行程序的命令，简单总结一下使用方法首先要说的是，linux任务调度的工作主要分为以下两类： 系统执行的工作：系统周期性所要执行的工作，如备份系统数据、清理缓存 个人执行的工作：某个用户定期要做的工作，例如每隔10分钟检查邮件服务器是否有信息，这些工作可由每个用户自行设置 系统任务可以通过编辑/etc/crontab文件给所有角色分配任务，格式如下1minute hour day month week user command 字段含义如下 minute： 表示分钟(0-59) hour： 表示小时(0-23) day： 表示日期(1-31) month： 表示月份(1-12) week： 表示星期几(0-7，这里的0和7代表周日) user: 执行命令的用户名 command： 要执行的命令，可以是系统命令，也可以是自己编写的脚本文件等 在以上各个字段中，还可以使用以下特殊字符： 星号(*)：代表所有可能的值，例如minute字段如果是星号，则表示在满足其它字段的制约条件后每每分钟都会执行 逗号(,)：可以用逗号隔开的值指定一个列表范围，例如’1,2,3,6’ 中杠(-)：可以用整数之间的中杠表示一个整数范围，例如’2-6’表示’2,3,4,5,6’ 正斜线(/)：可以用正斜线指定时间的间隔频率，例如’0-23/2’表示每两小时执行一次 修改/etc/crontab这种方法只有root用户能用，这种方法更加方便的直接给其他用户设置计划任务，指定执行命令等 用户任务Linux用户登录时，可以使用crontab -e编辑自身的定时任务，具体的使用方法如下12crontab [-u user] filecrontab [-u user] [ -e | -l | -r ] 命令参数含义 -u user：用来设定某个用户的crontab服务，此参数一般由root用户来运行 file：file是命令文件的名字,表示将file做为crontab的任务列表文件并载入crontab -e：编辑某个用户的crontab文件内容，默认为自身 -l：显示某个用户的crontab文件内容，默认为自身 -r：删除某个用户的crontab文件，默认为自身 -i：在删除用户的crontab文件时给确认提示 此外，可以在/var/spool/cron目录查看用户crontab配置文件 在编辑任务时，和系统任务相比少了角色的配置，其他参数相同1minute hour day month week command 举一些栗子每1分钟执行一次command1* * * * * command 每天早上7点半执行130 7 * * * command 每小时的第3和第15分钟执行13,15 * * * * command 在上午8点到11点的第3和第15分钟执行13,15 8-11 * * * command 每隔两天的上午8点到11点的第3和第15分钟执行13,15 8-11 */2 * * command 每个星期一的上午8点到11点的第3和第15分钟执行13,15 8-11 * * 1 command]]></content>
      <categories>
        <category>经验总结</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP执行命令关闭Linux服务器]]></title>
    <url>%2F2019%2F05%2F14%2Fshutdown%2F</url>
    <content type="text"><![CDATA[项目中的需求，希望用户可以通过后台关闭/重启内网服务器，记录下功能实现的过程功能主要分为三部分： Linux相关命令 php执行系统命令 服务器权限问题 关机命令我选择使用shutdown命令来关机，调用方式如下1shutdown [-t seconds] [-rkhncfF] time [message] 参数说明： -t seconds: 设定在几秒钟之后进行关机程序 -k: 并不会真的关机，只是将警告讯息传送给所有使用者 -r: 关机后重新开机 -h: 关机后停机 -n: 不采用正常程序来关机，用强迫的方式杀掉所有执行中的程序后自行关机 -c: 取消目前已经进行中的关机动作 -f: 关机时，不做fcsk动作(检查 Linux 档系统) -F: 关机时，强迫进行fsck动作 time: 设定关机的时间 message: 传送给所有使用者的警告讯息 举一些例子：123456shutdown -r now #立刻关机并重启shutdown -h now #立刻关机并停机shutdown -r +10 #10分钟后重启shutdown -r 10:00 #10点钟重启shutdown -t5 -r now #立刻重启, 但在警告和删除进程之间,延迟5秒钟.shutdown -c #取消之前的shutdown命令 当然，还有poweroff,reboot,halt,init这些其他的关机命令，大致用法如下123halt [-n] [-w] [-d] [-f] [-i] [-p] [-h]reboot [-n] [-w] [-d] [-f] [-i]poweroff [-n] [-w] [-d] [-f] [-i] [-h] php执行系统命令php提供了如下几种方法来执行系统命令 exec(): 执行外部程序返回命令执行结果的最后一行内容, 如果想要获取命令的输出内容, 请确保使用output参数 system(): 执行外部程序(命令行)，并且显示输出这个函数会将结果直接进行输出(注意是直接输出而不是返回值)，命令成功后返回输出的最后一行，失败返回FALSE shell_exec(): 通过shell环境执行命令，并且将完整的输出以字符串的方式返回命令执行的输出。 如果执行过程中发生错误或者进程不产生输出，则返回NULL passthru(): 执行外部程序并且显示原始输出 这里选用任何一个方法都可以，综上，要在php文件中执行关闭服务器的命令1exec('shutdown -h now'); 服务器权限如果服务器存在多个角色的话，实际执行shutdown命令的时候会出现如下报错12Please retry operation after closing inhibitors and logging out other users.Alternatively, ignore inhibitors and users with &apos;systemctl reboot -i&apos;. 这种情况下可以通过使用sudo命令执行shutdown来进行关机，那么就涉及到一个问题，如何在php文件中调用sudo，我查到到了一种解决方案，在etc/sudoers文件配置以下权限1%xxx ALL=(ALL) NOPASSWD: ALL // 设置xxx组下面的用户使用sudo不需要输入密码 首先要做的是获取到执行php脚本的用户，一般都是www-data，不清楚的话可以在php文件中使用以下方法获取用户名1system(&apos;whoami&apos;); 还有一个问题就是，给用户开放所有免密权限，风险实在太大了，我们只需要开放shutdown的权限就好了，所以最终的配置应该是1%www-data ALL=(ALL) NOPASSWD: /sbin/shutdown 在php文件中执行1exec('sudo shutdown -h now');]]></content>
      <categories>
        <category>经验总结</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Predis操作Redis]]></title>
    <url>%2F2019%2F05%2F09%2Fpredis%2F</url>
    <content type="text"><![CDATA[Predis是php连接Redis的操作库，支持已知的所有Redis客户端命令，由于项目中用来处理session和数据缓存，简单整理一下 安装1composer require predis/predis 使用如果在连接时不加任何参数，默认会把127.0.0.1和6379作为默认的host和port并且连接超时时间是5秒，以下几种声明方式均可123456789101112// 默认连接$redis = new Predis\Client();// 数组形式$redis = new Predis\Client([ 'scheme' =&gt; 'tcp', 'host' =&gt; '127.0.0.1', 'port' =&gt; 6379,]); // URI 形式:$redis = new Predis\Client('tcp://127.0.0.1:6379'); Client的更多配置参数可以通过第二个参数传进去1234$client = new Predis\Client( $connection_parameters, ['profile' =&gt; '2.8', 'prefix' =&gt; 'sample:']); Redis会给所需要的参数默认值，参数主要有： profile: 针对特定版本的配置，因为不同版本对同样操作可能有差异 prefix: 自动给要处理的key前面加上一个前缀 exceptions: Redis出错时是否返回结果 connections: 客户端要使用的连接工厂 cluster: 集群中使用哪个后台 (predis, redis或者客户端配置) replication: 主/从中使用哪个后台 (predis或者客户端配置) aggregate: 合并连接方式 (覆盖cluster和replication) 以下是常用的操作方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// 普通set/get操作$redis-&gt;set('library', 'predis');$redis-&gt;get('library'); // 'predis'// del 删除$redis-&gt;del('foo'); // setex set一个存储时效$redis-&gt;setex('str', 10, 'bar'); // 表示存储有效期为10秒 // setnx/msetnx 相当于add操作,不会覆盖已有值$redis-&gt;setnx('foo',12); // true$redis-&gt;setnx('foo',34); // false // getset操作,set的变种,结果返回替换前的值$redis-&gt;getset('foo',56); // 返回34 // incrby/incr/decrby/decr 对值的递增和递减$redis-&gt;incr('foo'); // foo为57$redis-&gt;incrby('foo',2); // foo为59 // exists检测是否存在某值$redis-&gt;exists('foo'); // true // type 类型检测,字符串返回string,列表返回list,set表返回set/zset,hash表返回hash$redis-&gt;type('foo'); // 不存在,返回none$redis-&gt;set('str','test');$redis-&gt;type('str'); // 字符串，返回string // append 连接到已存在字符串$redis-&gt;append('str','_123'); // 返回累加后的字符串长度8,此进str为 'test_123' // setrange 部分替换操作$redis-&gt;setrange('str',0,'abc'); // 返回3,参数2为0时等同于set操作$redis-&gt;setrange('str',2,'cd'); // 返回4,表示从第2个字符后替换,这时'str'为'abcd' // substr 部分获取操作$redis-&gt;substr('str',0,2); // 表示从第0个起，取到第2个字符，共3个，返回'abc' // strlen 获取字符串长度$redis-&gt;strlen('str'); // 返回4 // setbit/getbit 位存储和获取$redis-&gt;setbit('binary',31,1); // 表示在第31位存入1,这边可能会有大小端问题?不过没关系,getbit 应该不会有问题$redis-&gt;getbit('binary',31); // 返回1 // keys 模糊查找功能,支持*号以及?号(匹配一个字符)$redis-&gt;set('foo1',123);$redis-&gt;set('foo2',456);$redis-&gt;keys('foo*'); // 返回满足条件的键值对数组 ['foo1', 'foo2']$redis-&gt;keys('f?o?'); // 同上 // randomkey 随机返回一个key$redis-&gt;randomkey(); // 可能是返回 'foo1'或者是'foo2'及其它任何一存在redis的key // rename/renamenx 对key进行改名,所不同的是renamenx不允许改成已存在的key$redis-&gt;rename('str','str2'); // 把原先命名为'str'的key改成了'str2' // expire设置key-value的时效性,ttl获取剩余有效期,persist重新设置为永久存储$redis-&gt;expire('foo', 1); // 设置有效期为1秒$redis-&gt;ttl('foo'); // 返回有效期值1s$redis-&gt;expire('foo'); // 取消expire行为 // dbsize 返回redis当前数据库的记录总数$redis-&gt;dbsize();]]></content>
      <categories>
        <category>插件工具</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Npm代理和镜像源设置]]></title>
    <url>%2F2019%2F04%2F25%2Fnpm-proxy%2F</url>
    <content type="text"><![CDATA[今天又被npm这个东西坑了一次，整理下我找到的一些方法 代理设置设置代理和https代理12npm config set proxy=http:/server:portnpm config set https-proxy http://server:port 认证用户名和密码12npm config set proxy http://username:password@server:portnpm confit set https-proxy http://username:password@server:port 删除代理12npm config delete proxynpm config delete https-proxy 镜像源设置12npm config set registry http://registry.npmjs.orgnpm config set registry https://registry.npm.taobao.org 全局配置文件设置npm config edit打开.npmrc文件 ，在文件中如下位置添加如下代码12345678910111213;;;;; npm userconfig file; this is a simple ini-formatted file; lines that start with semi-colons are comments.; read `npm help config` for help on the various options;;;;registry=http://registry.npmjs.org/proxy=http://10.127.0.0.1:1008/;;;;; all options with default values;;;; 使用nrm切换npm源安装1npm install nrm -g 列出可用的源1234567-&gt; nrm lsnpm ---- https://registry.npmjs.org/cnpm --- http://r.cnpmjs.org/taobao - https://registry.npm.taobao.org/nj ----- https://registry.nodejitsu.com/npmMirror https://skimdb.npmjs.com/registry/edunpm - http://registry.enpmjs.org/ 切换12-&gt; npm use taobaoRegistry has been set to: http://registry.npm.taobao.org/ 增加源1nrm add taobao http://registry.npm.taobao.org/ 删除源1nrm del taobao 测试速度1nrm test taobao npm config相关命令1234567npm config set &lt;key&gt; &lt;value&gt; [-g|--global]npm config get &lt;key&gt;npm config delete &lt;key&gt;npm config listnpm config editnpm get &lt;key&gt;npm set &lt;key&gt; &lt;value&gt; [-g|--global]]]></content>
      <categories>
        <category>经验总结</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Npm包：electron-update-helper]]></title>
    <url>%2F2019%2F04%2F24%2Felectron-update-helper%2F</url>
    <content type="text"><![CDATA[依赖electron-builder和electron-updater的electron版本更新方法，自己基于原有方法进行了封装 安装使用npm1npm install electron-update-helper 使用主进程，在创建BrowserWindow后使用MainHelper，初始化实例即可，详见‘demo’12345678910111213import &#123;MainHelper&#125; from 'electron-update-helper'app.on('ready', () =&gt; &#123; mainWindow = new BrowserWindow(&#123; height: 768, width: 1024 &#125;); // 接受两个参数 // 1 创建的BrowserWindow对象 // 2 版本更新地址，需要和package.json中electron-builder的publish url配置相同 new MainHelper(mainWindow, URL);&#125;); 渲染进程中，使用RenderHelper123import &#123;RenderHelper&#125; from &apos;electron-update-helper&apos;let renderHelper = new RenderHelper(); 渲染进程事件，详见‘demo’ checkForUpdates: 触发版本更新 1renderHelper.checkForUpdates(); setMessageHandle: 更新通知的处理函数，参数为以下四种提示 12345678910111213141516renderHelper.setMessageHandle(message =&gt; &#123; switch (message) &#123; case 'error': alert('更新异常'); break; case 'checking': alert('开始检查更新'); break; case 'update': alert('正在下载更新中'); break; case 'new': alert('当前是最新版本，无需更新'); break; &#125;&#125;); setProgressHandle： 进度条处理函数，参数为进度条对象 123renderHelper.setProgressHandle(progressObj =&gt; &#123; console.log(`当前更新进度为$&#123;progressObj.percent&#125;`);&#125;); setUpdatedHandle: 更新完成后的回调，参数为一个事件，当done方法被调用时，会退出并执行更新 12345renderHelper.setUpdatedHandle(done =&gt; &#123; if (confirm('已下载完成,现在退出并更新吗？')) &#123; done(); &#125;&#125;); 注意事项在使用electron-updater进行版本更新时，需要在package.json中添加一下配置，注意url地址应当与MainHelper传入的一致123456789101112131415&#123; "build": &#123; "productName": "Name", "appId": "org.simulatedgreg.electron-vue", "publish": [ &#123; "provider": "generic", "url": "your url" &#125; ], "directories": &#123; "output": "build" &#125; &#125;&#125; 依赖 ‘Electron-builder’ ‘electron-updater’]]></content>
      <categories>
        <category>插件工具</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>electron</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue插件:Vue-lazyload-widget]]></title>
    <url>%2F2019%2F03%2F14%2Flazyload-widget%2F</url>
    <content type="text"><![CDATA[基于浏览器‘IntersectionObserver’接口，实现的Vue懒加载组件，目前还没有开发完成，初步计划是有实现图片懒加载以及模块的懒加载两种内容，分别以指令和组件的形式来使用 安装使用npm1npm install vue-lazyload-widget 在main.js中引入123import vueLazyloadWidget from 'vue-lazyload-widget'Vue.use(vueLazyloadWidget) 直接引入文件1&lt;script src="path/vue-lazyload-widget.js"&gt;&lt;/script&gt; 图片懒加载设置图片路径时有两种可用方式，直接将路径设置为指令属性值或者设置为data-src属性123&lt;img v-lazy-img="path"&gt;// or&lt;img dat-src="path" v-lazy-img&gt; 图片路径需要设置绝对路径，或者提前引入图片，参考‘Demo’ 组件懒加载1234&lt;lazy-widget&gt; &lt;!--组件内容--&gt; &lt;div slot="skeleton"&gt;&lt;!--预加载内容，比如骨架--&gt;&lt;/div&gt;&lt;/lazy-widget&gt; 没有设置骨架时，组件未加载之前默认显示loading图片 组件Event接受唯一参数el,为当前组件dom实例 before-leave: 预加载内容即将离开 after-leave: 预加载内容已离开 before-enter: 组件内容即将进入 after-enter: 组件内容已进入 before-init: 组件内容即将被渲染 after-enter: 组件内容已渲染完成 关于配置项目前包括以下配置项 root 视图窗口viewport的dom对象，默认为当前浏览器窗口 rootMargin 触发懒加载的视图外边距，默认值为”0px 0px 0px 0px”，例如设置为”10px”时，会在距离视图10px时开始加载 目前设计的有三种配置方式，按优先级从低到高来看 在注册时直接传入 12const options = &#123;&#125;;Vue.use(vueLazyloadWidget, options) 组件中修改配置项，会优先读取组件中的lazyOptions属性 123456data () &#123; lazyOptions: &#123; root: null, rootMargin: '0px' &#125;&#125; 组件注册时传入,如果父组件内有定义，会直接读取父级配置，只有需要单独对组件进行配置时需要传入 1&lt;lazy-widget :options="lazyOptions" :height="100"&gt;&lt;/lazy-widget&gt; 组件上额外的配置 height: 表示组件内容未加载时的高度，默认为50px name: 组件中transition过度组件的name，用于设置过渡动画，默认为lazy-widget 过渡动画默认的过渡动画效果为123456.lazy-widget-enter-active &#123; transition: opacity .5s;&#125;.lazy-widget-enter&#123; opacity: 0;&#125; 可以通过自定义样式和name来修改过渡动画 兼容性由于主要依赖于‘IntersectionObserver’接口，目前只适用于部分高版本浏览器，如果要兼容低版本，需要额外安装‘IntersectionObserver Polyfill’1npm install intersection-observer 之后在文件内引入即可1require('intersection-observer'); or1&lt;script src="path/intersection-observer.js"&gt;&lt;/script&gt; 注意intersection-observer的引用要在本组件之前 参考 ‘IntersectionObserver’ ‘hilongjw/vue-lazyload’ ‘xunleif2e/vue-lazy-component’]]></content>
      <categories>
        <category>插件工具</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回顾一下我的2018]]></title>
    <url>%2F2019%2F01%2F22%2Freview-2018%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;每次到年初都会觉得上一年是过的最快的一年，但是这次我真的觉得，过去的一年是我过的最充实的一年，感觉自己经历了很多，收获了很多。一句话来总结的话，就是完成了从蹒跚学步到独当一面的转变（咳咳）。&emsp;&emsp;2017年大学毕业，毕业答辩完的第二天开始投简历，在经历了3次失败的面试后到了现在所在的公司，求职过程顺利的不可思议，一直到现在我想想都会觉得很疑惑，当时我是怎么混进来的。于是带着大学自学的一些基础和零星的实习经验，就这样开始了我作为一个菜鸟前端工程师的生涯，半年时间辗转经历了3个项目，自己一直是抱着学习的心态在不断的积累，直到年底新项目开始。。。 &emsp;&emsp;这个项目几乎贯穿了我整个2018年，是一个为上海某俱乐部私人定制的一套包含管理后台，点餐收银系统，APP，微信小程序，游戏控制器等内容的大项目，也由此拉开了我被赶鸭子上架强行速成的序幕，先来回顾一下一些我主要学到的东西 PHP： emmm..由于管理端使用的是一个基于Laravel改写的php框架，在项目缺人的情况下，只能让某前端开发者自行负责需要的接口，于是便一发不可收拾了，在项目进行了一年后的今天，基本上已经算是后台主力了 Electron： 我们的点餐收银系统是使用electron-vue进行开发的一款桌面应用，从架构，开发到上线都由我一个人负责，在踩过无数次的坑之后，可以说是比较熟悉了 Vue： 作为我最喜欢的一个前端框架，在公司项目和个人项目都是首选，过去的一年自己也写了几个小插件，并且研究了一段时间的源码，感兴趣的可以戳‘Vue源码分析’ Nginx： 最近的接触的项目基本上都是ubuntu + nginx的组合，于是自己也买了个服务器开始折腾，在经历了个人和项目的摧残之后，也算是初见成效 Linux： 同上，尤其是在项目上线到现在的维护阶段，基本上每天都要收到客户反馈去查各种log，面临各种问题，讲道理十分羡慕其他同事花里胡哨的各种命令操作，这也是今年的主要目标之一 Docker： 感觉从下半年开始就不停的听到容器这个概念，在公司每月的技术分享上也有大佬进行了全方位解析（虽然大部分没听懂），后来自己也查阅过相关资料，大概了解了基本使用 三方平台的对接： 经历很多和三方平台对接的业务，比如微信支付宝的支付退款，登录功能，App用到的极光推送以及收银用到的旺POS等 &emsp;&emsp;当然除了拓宽了技术栈之外，还有很多其他的收获的，比如说这是第一个我直接跟客户沟通的项目，自己一个人出差到上海店里确认需求，维护系统。从埋头写代码到现在的转变，我觉得是一个很好的开始。 &emsp;&emsp;另外最大的收获就是在十一的时候开始了我的房奴生涯，而且由于今年国家政策比较好，导致我比正常情况下多出了一千多的月供，从此开始了在家混吃混喝基本月光的生活。值得一提的是，交房是在2020年10月，刚好是在本命年生日过后。 &emsp;&emsp;一时间也想不起来有什么要写的，直接进行最后一步吧，展望一下美好的2019： 去年学会了php，今年的目标就暂定为node吧 熟悉Linux命令和服务器配置 学英语！学英语！学英语！ 出国旅行一次 &emsp;&emsp;正式告别22岁的自己，希望在明年年初回忆今年的时候，也是充满收获的一年！ Over]]></content>
      <categories>
        <category>年度总结</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[微信&支付宝退款]]></title>
    <url>%2F2019%2F01%2F10%2Fwechat-refund%2F</url>
    <content type="text"><![CDATA[在之前做支付的时候我就想着可能会有这么一天，该来的终究是要来的，这两天开始研究一下微信和支付宝的退款关于微信支付的方法可以看一下在我之前写的一篇博客‘微信H5支付&amp;公众号支付大型攻略’，几个月过去了，现在想想还是觉得很难受，完全不想再回忆这个流程 支付宝先来看一下支付宝的文档‘统一收单交易退款接口’，可以说是非常贴心了，下面直接贴了各种语言的demo，基本上复制粘贴过来参数改了就能用了，需要依赖官网SDK‘SDK下载’，下面上代码123456789101112131415161718192021222324252627$aop = new AopClient ();// 设置请求参数$aop-&gt;gatewayUrl = 'https://openapi.alipay.com/gateway.do';$aop-&gt;appId = 'appid';$aop-&gt;rsaPrivateKey = '商户私钥';$aop-&gt;alipayrsaPublicKey = '支付公钥';$aop-&gt;apiVersion = '1.0';$aop-&gt;signType = 'RSA2';$aop-&gt;postCharset = 'GBK'; // 这里要注意编码一致，虽然文档写的是GBK，但是大部分情况下都是UTF-8$aop-&gt;format = 'json';$request = new AlipayTradeRefundRequest ();$request-&gt;setBizContent(json_encode([ 'out_trade_no' =&gt; $this-&gt;order['order_sn'], // 外部订单号，与流水号二选一 'trade_no' =&gt; $this-&gt;order['trade_no'], // 支付时支付宝返回的流水号，与外部订单号二选一 'refund_amount' =&gt; $this-&gt;order['order_amount'] // 退款金额，单位是元，支持两位，需要和微信区别开]));// 处理参数，发起请求$result = $aop-&gt;execute($request);// 拿到请求响应数据 $result-&gt;$responseNode $responseNode = str_replace(".", "_", $request-&gt;getApiMethodName()) . "_response";$resultCode = $result-&gt;$responseNode-&gt;code;if(!empty($resultCode) &amp;&amp; $resultCode == 10000)&#123; // 成功&#125; else &#123; // 失败&#125; 以上就是需要配置的一些参数了，还有一些请求参数都是在sdk方法中完成的，接下来看一下微信的，基本上也是依赖官方sdk的 微信依旧先找到文档‘微信支付开发文档’，下载sdk‘SDK下载’，不过微信的sdk，在使用的时候基本上都需要根据自己项目二次封装，这里就不多说了，主要需要用到的是WxPay.Api.php和WxPay.Data.php12345678910111213141516// 封装后的WxPay.Data.php$input = new WxPayRefund();$input-&gt;SetAppid('appid');$input-&gt;SetMch_id('mch_id');$input-&gt;SetOut_trade_no($this-&gt;order['order_sn']); // 外部订单号和交易单号至少要有一个$input-&gt;SetOut_refund_no($this-&gt;order['order_sn'] . time()); // 需要保证每次退款的退款号不同$input-&gt;SetTotal_fee($this-&gt;order['order_amount'] * 100); // 订单总额，主意单位为分$input-&gt;SetRefund_fee($this-&gt;order['order_amount'] * 100); // 退款金额// 调用WxPay.Api.php中的refund方法，返回的数据格式是数组$result = WxPayApi::refund($input);if ($result['return_code'] != 'SUCCESS') &#123; // 成功&#125; else &#123; // 失败&#125; 代码部分看上去很简单，不过需要注意的细节还是挺多的，不过做过微信支付的话再做退款可以说是轻车熟路了，大部分东西都已经配好了，不过需要注意的一点就是退款相比支付需要安装一个微信支付安全证书，首先这个证书是需要在微信商户后台进行申请的，关于流程微信文档写的还是比较详细的，照着一步一步来就好了‘如何获取API证书’ 然后照着文档把证书申请下载下来之后，接下来的问题就是怎么使用证书了，文档上是这么写的1请将生成的证书文件转交给技术人员，由技术人员将证书部署到服务器上 你tm在逗我？无奈之下只好自己研究了一下，发现sdk中调用退款请求时，比支付多了一个参数，顺着找到了postXmlCurl方法1234567891011121314151617181920private static function postXmlCurl($xml, $url, $useCert = false, $second = 30)&#123; $ch = curl_init(); //设置超时 curl_setopt($ch, CURLOPT_TIMEOUT, $second); …… if($useCert == true)&#123; //设置证书 //使用证书：cert 与 key 分别属于两个.pem文件 //证书文件请放入服务器的非web目录下 $sslCertPath = ""; $sslKeyPath = ""; $config-&gt;GetSSLCertPath($sslCertPath, $sslKeyPath); curl_setopt($ch,CURLOPT_SSLCERTTYPE,'PEM'); curl_setopt($ch,CURLOPT_SSLCERT, $sslCertPath); curl_setopt($ch,CURLOPT_SSLKEYTYPE,'PEM'); curl_setopt($ch,CURLOPT_SSLKEY, $sslKeyPath); &#125; ……&#125; 也就是说把证书丢在服务器上面之后将这里的路径指向两个文件就好了，需要注意的是一定要放在有权限的文件夹下，防止被其他人下载到，还有就是这里的路径需要时绝对路径，否则会返回错误58 over！]]></content>
      <categories>
        <category>经验总结</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>微信</tag>
        <tag>支付宝</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Electron阻止应用多开]]></title>
    <url>%2F2018%2F12%2F13%2Felectron-single%2F</url>
    <content type="text"><![CDATA[最近发现electron启动的应用，默认是可以多开的，这就导致可能出现启动时手滑等其他情况，导致会有多个进程同时运行，造成卡顿查阅官方文档没有发现任何关于这方面的方法，然后在神奇的知乎发现了一下代码123456789let iShouldQuit = app.makeSingleInstance(() =&gt; &#123; mainWindow.show(); mainWindow.focus(); return true;&#125;);if (iShouldQuit) &#123; app.quit();&#125; 在主进程启动时调用，makeSingleInstance事件据说是在验证当前实例是唯一实例时会触发，所以可以根据它来进行验证，当判断方法被执行时，退出正在启动的应用 试了一下可以实现效果，但是不明白为什么文档里没有这个API]]></content>
      <categories>
        <category>项目实例</category>
        <category>经验总结</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>electron</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[查询日期范围内固定时段的数据]]></title>
    <url>%2F2018%2F11%2F08%2Fdate-sql%2F</url>
    <content type="text"><![CDATA[之前遇到一个需求，需要查询日期范围内某一固定时段的数据，因为没有碰到过这种情况，当时也是挺头疼的，记录下自己的解决方法吧举个例子，查询2018-10-01到2018-11-01中，每天9:00到12:00的数据 首先想到的第一个办法就是利用Eloquent自带的查询方法12345Model::whereDate('created_at', '&gt;=', '2018-10-01') -&gt;whereDate('created_at', '&lt;=', '2018-11-01') -&gt;whereTime('created_at', '&gt;=', '09:00') -&gt;whereTime('created_at', '&lt;=', '12:00') -&gt;get(); 算是最简单的解决这种需求的方法，但是可惜的是数据库中存的并不是日期格式，而是10位的unix时间戳，不过也算是从laravel这个方法中得到启发，想到了利用SQL直接格式化时间来查询的方法12select * from orders where add_time &gt;= 1538323200 and add_time &lt;= 1541001600 and FROM_UNIXTIME(add_time, "%H") &gt;= 9 and FROM_UNIXTIME(add_time,"%H") &lt; 12 使用FROM_UNIXTIME(unix_timestamp,format)方法，将时间戳格式化为小时数后进行查询]]></content>
      <categories>
        <category>项目实例</category>
        <category>经验总结</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于移动端网页尺寸问题]]></title>
    <url>%2F2018%2F10%2F23%2Fmobile-media%2F</url>
    <content type="text"><![CDATA[前几天见到有同事讨论这个问题，今天有时间了就把目前我知道的移动端开发时，对于尺寸处理的方法整理一下首先是大部分人都熟悉的rem了，rem的值等于文档对象字体大小，默认为16px，我们做移动端开发时，通常是通过视图宽度来计算rem的值，从而达到响应页面的效果 js计算rem12let element = document.documentElement;element.style.fontSize = `$&#123;element.clientWidth / 3.75&#125;px`; 通常设计给的设计图都是375px的宽度，这样出来的1rem对应设计图100px，算是一个个人习惯吧，因人而异，我觉得这么比较好计算 css计算rem123html&#123; font-size: calc(100vw / 3.75);&#125; 通过直接修改html字体元素也可以修改rem值，原理同上 设置页面缩放宽度如果不想计算rem的话还有一种方式，就是直接修改meta标签1&lt;meta name="viewport" content="width=375, user-scalable=no"&gt; 将页面宽度固定设置为375px，就会起到如下的效果768px的宽度被强制缩放为375px]]></content>
      <categories>
        <category>经验总结</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>html</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue插件:Vue-nice-loading]]></title>
    <url>%2F2018%2F10%2F07%2Fvue-loading%2F</url>
    <content type="text"><![CDATA[逛github的时候发现一些挺好看的svg图片，就想着自己用这些写一个vue的loading插件Demo: ‘https://www.liyu.fun/vue-nice-loading’ Demo源码示例： ‘https://github.com/gitliyu/vue-nice-loading/blob/master/example/demo.vue’ Github地址： ‘https://github.com/gitliyu/vue-nice-loading’ 安装1npm i vue-nice-loading 在main.js中引入123import loading from 'vue-nice-loading'Vue.use(loading) 使用Vue.use初始化后会在vue原型上注册$loading，调用$loading方法显示loading，并返回实例，调用实例的close方法可以关闭该loading12345678// 显示loadinglet loading = this.$loading(&#123; text: 'loading'&#125;)// 关闭loadingsetTimeout(() =&gt; &#123; loading.close();&#125;, 3000) 支持直接引入js文件的使用方式 $loading方法接受以下参数 type loading显示的种类，这里使用的所有svg图片取自‘SVG-Loaders’, 接受值与图片名相同，默认值为ball-triangle，共有以下12种 audio ball-triangle bars circles grid hearts oval puff rings spinning-circles tail-spin three-dots 123this.$loading(&#123; type: 'bars'&#125;) target loading需要覆盖的dom节点, 可传入一个dom对象或选择器的字符串，默认为body，显示全屏loading12345this.$loading(&#123; target: '#app' // target: this.$refs.app // target: document.querySelector('#app')&#125;) text 显示文本，默认为空 123this.$loading(&#123; text: 'Loading...'&#125;) background 遮罩层背景色 123this.$loading(&#123; background: '#333'&#125;) delay 延时显示，单位为毫秒，以下例子会在1s后显示123this.$loading(&#123; delay: 1000&#125;) 技术支持‘SVG-Loaders’‘ElementUI’]]></content>
      <categories>
        <category>插件工具</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue源码分析]]></title>
    <url>%2F2018%2F09%2F08%2Fvue-note%2F</url>
    <content type="text"><![CDATA[个人学习Vue源码过程中的一些总结，对应Vue版本为2.5.17最近开始研究Vue源码，在看的过程中自己做一些归纳总结，之前打算放在博客更新了，但是感觉内容比较多，所以就统一放在‘我的Github’进行整理了，目前包括以下内容： Vue ‘源码目录结构’ ‘Vue实例化过程’ ‘Global API’ ‘Observer与响应式数据’ ‘Virtual DOM 介绍’ ‘数据驱动视图的方法’ ‘Patch与Diff算法’ ‘异步更新机制’ ‘生命周期’ ‘Vue实例属性’ 指令 vue-router ‘源码目录结构’ ‘Install安装方法’ ‘VueRouter类介绍’ ‘路由匹配’ ‘RouterLink组件’ ‘RouterView组件’ ‘前端路由实现：Hash和History模式’ 技术支持 ‘vue2.0-source’ ‘vue-analysis’ ‘learnVue’ ‘Vue源码之new Vue’]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信授权注册&登录]]></title>
    <url>%2F2018%2F08%2F23%2Fwechat-login%2F</url>
    <content type="text"><![CDATA[首先要明确一点，这里指的是在微信内浏览器使用的，利用微信公众号获取用户授权信息之后进行的注册登录，在经过上一次微信支付的摧残之后，这次做登录流程要顺利得多，简单描述一下流程。首先贴一下微信开发者文档中对于网页授权的说明文档‘戳这里’，对于授权的接口如何使用，我这里不会详细的说明，文档对于接口参数写的还是比较清楚的，主要介绍一下注册流程 准备工作 确保公众号可以使用，拿到appid和密钥 微信公众平台修改授权回调页面 可以使用微信开发者工具调试 获取用户授权1https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=snsapi_userinfo&amp;state=STATE#wechat_redirect 这一步和微信支付的授权唯一的区别就在于scope属性的不同，由于我们需要获取用户信息，就不能使用静默授权，而是使用scope=snsapi_userinfo，通过在前台请求api，拉取授权页面，用户同意之后在回调页面获取code值。 获取用户openid使用上一步拿到的code值，请求以下api1https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;secret=SECRET&amp;code=CODE&amp;grant_type=authorization_code 这一步需要放在服务端请求，前端会跨域，请求成功后拿到返回的access_token和’openid’ 微信登录拿到用户openid之后，就可以查询数据库中用户信息了（注册时把用户微信登陆的openid和unionid存一下），如果有已经注册过的用户，直接登录，没有的话继续走注册流程 拉取用户信息使用openid和access_token发起请求1https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&amp;openid=OPENID&amp;lang=zh_CN 前台会跨域，同样放在后台进行，这样就拿到了微信用户的详情信息 注册用户使用拿到的用户信息创建用户，成功后直接登录 需要注意的一点是，如果有多个微信应用时，同一用户在app，公众号，小程序这些获取到的openid都是不同的，但是unionid是唯一的，可以通过unionid来进行用户的识别 结束语： 没错，这一篇就是这么短！]]></content>
      <categories>
        <category>经验总结</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>javascript</tag>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最近做的测试题]]></title>
    <url>%2F2018%2F08%2F02%2Ftest%2F</url>
    <content type="text"><![CDATA[整理一下最近做的一些比较有意思的测试题，大部分是js的1.闭包1234567891011121314151617181920function test () &#123; var n = 4399; function add () &#123; n++; console.log(n); &#125; return &#123; n: n, add: add &#125;&#125;var result = test();var result2 = test();result.add();result.add();console.log(result.n)result2.add(); result两次调用add函数，每次使自身内部的n值加1，前两次输出为4400，4401之后打印result上的n属性，因为是最初赋值的n，与闭包函数内部定义的变量n无关，输出4399最后result2和result是独立的，互不影响，输出4400最终结果是12344400440143994400 2.函数声明1234var f = function g() &#123; return 23;&#125;;console.log(typeof g()); 我的第一反应就是，结果明显是’number’，仔细看了看，f是以一个匿名函数做的函数声明，实际上是没有g这个函数方法的，所以最终结果是1ReferenceError，g is not defined 3.数组长度1234567var arr = [];arr[0] = 0;arr[1] = 1;arr.foo = 'c';arr[3] = 3;console.log(arr.length); 讲道理我之前还没见过这种给数组设置属性值的操作，不过数组的本质也是对象，直接设置属性也可以，并不会出错，最后生成的数组为[0, 1, empty, 3]， length为4 4.类型转换123console.log( ([]) ? true : false ); console.log( ( [] == false ? true : false ) ); console.log( ( &#123;&#125; == false ) ? true : false ); 首先需要明确的几点： [] 和 {} 为 true 在进行比较比较运算时，会进行强制类型转换 在进行强制类型转换后，[]结果为0, {}结果为NaN 所以上述代码也可以看作123console.log( true ? true : false );console.log( 0 == 0 ? true : false );console.log( NaN == 0 ? true : false); 最终结果为123truetruefalse 5.假设val已经声明,可定义为任何值1console.log('Value is ' + (val != '0') ? 'define' : 'undefine'); 这道题我的答案是12Value is defineValue is undefine 然而并没有这么简单，问题只有一点，就是符号优先级的问题，+号是先于三目运算符进行运算的，所以最终结果是1define 6.异或和左移运算12345function a (a) &#123; a ^= ( 1 &lt;&lt; 4 ) - 1; return a;&#125;console.log(a(10)); 首先是左移运算符: 1 &lt;&lt; 4 将1转换为二进制数后向左移动4位，即 1 &lt;&lt; 4 = 10000 = 16那么执行a(10)之后进行的运算就相当于是 10 ^= 15，转换为二进制后进行按位异或运算1210 = 0000101015 = 00001111 得到结果为: 00000101 = 5 7.变量声明赋值和作用域12345678910var a,b;(function()&#123; alert(a); alert(b); var a=b=3; alert(a); alert(b);&#125;)();alert(a);alert(b); 第一组结果十分明显，由于变量a, b是全居变量，声明后未赋值，所以结果是undefined，undefined第二组也很简单，变量a, b都被赋值为3，所以结果是3, 3第三组把我坑到了，当进行 var a=b=3的赋值时，实际进行的操作为12b = 3;var a = b; 将b作为全局变量进行赋值，而a是重新声明的，所以结果为undefined, 3 8.静态属性12345678910class A&#123; public static $num = 0; public function __construct()&#123; self::$num++; &#125;&#125;new A();new A();new A();echo A::$num; 如果$num不是static属性的话，结果应该是0，每次实例化A时$num值都不会影响，但是static属性常驻内存，不会被立即删除，所以输出是 3 9.this指向1234567891011var color = 'green';var obj = &#123; color: 'blue', getColor: function () &#123; color = 'red'; console.log(this.color); &#125;&#125;var getColor = obj.getColor;getColor();obj.getColor(); js中的this关键字指向的是调用方法的对象，在声明之后使用getColor()方法调用，this指向window对象，而在方法调用时，全局的color被重新赋值为red，对象调用时，this指向自身的属性，所以输出结果为12redblue 10.运算符和类型转换1234console.log(1+ "2" + "2");console.log(1 + +"2" + "2");console.log("A" - "B" + "2");console.log("A" - "B" + 2); 这里用到的几个知识点: 在与字符串进行加法运算时，会将其他类型转换为字符串 一元加运算符，会将变量转换为数字类型 进行减法运算时，强制转换为数字进行运算 所以上面的计算过程12341 + "2" + "2" = "12" + "2" = "122"1 + +"2" + "2" = 1 + 2 + "2" = 3 + "2" = 32"A" - "B" + "2" = NaN + "2" = "NaN2""A" - "B" + 2 = NaN + 2 = NaN 11.变量引用与作用域123for (var i = 0; i &lt; 10; i++) &#123; setTimeout(function() &#123; console.log(i); &#125;, 100);&#125; 看到上面这段代码，有js基础的童鞋应该都明白，输出的结果应该是10个10，而不是0-9，因为每次定时器函数执行时，拿到的是同一个i值，那么如何顺利的输出想要的结果呢12345for (var i = 0; i &lt; 10; i++) &#123; (function(i) &#123; setTimeout(function() &#123; console.log(i); &#125;, 100); &#125;)(i);&#125; 用自调用函数来分割函数作用域，每次执行拿到的都是单独作用域中的i值，这样就可以输出0-9了 To Be Continue]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[伪静态地址获取用户头像]]></title>
    <url>%2F2018%2F07%2F20%2F%E4%BC%AA%E9%9D%99%E6%80%81%2F</url>
    <content type="text"><![CDATA[项目需求：使用伪静态地址 example.com/avatar/xxx (xxx为user id)的形式，直接获取用户头像图片 获取图片信息首先需要创建一个get请求接口来根据user_id拿到用户头像的图片信息，路由地址为/app/user/avatar12345678$user_id = $_GET['user_id'];$avatar_img = DB::table('users')-&gt;where('user_id', $user_id)-&gt;pluck('avatar_img');header("Content-type: image/png;charset=utf-8");echo file_get_contents($avatar_img, true);exit; 这样就可以根据/app/user/avatar?user_id=xxx的方式拿到图片，接下来需要做的就是修改服务器配置，将伪静态地址重定向到api地址 重定向服务器使用的是nginx服务器，其他的就不介绍了首先找到配置文件nginx.conf，默认安装位置位于/etc/nginx，不过一般不要直接修改这个，创建一个单独的conf文件，然后在nginx.conf中使用include引入使用。在配置文件中添加一下配置：123location / &#123; rewrite ^/avatar/(.*)$ /app/user/avatar?user_id=$1 last;&#125; 保存后退出编辑模式，重启nginx1nginx -s reload 补充一下修改配置文件会用到的命令 1234vi nginx.conf // 文本编辑器打开文件set num // 显示编辑器行号:w // 保存:wq! // 保存后退出]]></content>
      <categories>
        <category>项目实例</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信H5支付&公众号支付大型攻略]]></title>
    <url>%2F2018%2F06%2F15%2Fwechat%2F</url>
    <content type="text"><![CDATA[首先必须要吐槽一下，可能真的是我天资愚钝，看不懂微信的文档，导致这几天在做微信支付的时候踩了很多的坑，为了避免以后再次出现这样的情况，忍痛回忆一下这几天的经历。先来说一下需要做的准备工作吧 申请开通微信H5支付及公众号支付(‘微信商户平台’-&gt;产品中心-&gt;支付产品) 设置网站授权目录(同上-&gt;开发设置)这里需要注意的是，H5支付设置当前域名即可，公众号支付需要设置为支付页面所在目录(比如支付页面路径为xxxx.com/pay，H5设置xxxx.com即可，公众号需要设置xxxx.com/pay) 设置js接口安全域名和授权目录(‘微信公众平台’-&gt;接口权限)设置为域名即可(这里需要注意www的问题，需要保持一致，如果设置位xxx.com，那么在www.xxx.com 访问的时候，微信会认为没有权限)，之后把微信提供的文本文件放在服务器根目录 拿到公众号的appid和密钥 商户号和商户密钥(‘微信商户平台’-&gt;账户设置-&gt;API安全-&gt;密钥设置) ok，准备工作完成之后，就可以开始我们的大型攻(cai)略(keng)了, 先来介绍一下项目需求，这次做的是一个扫码在线点餐的网页，由于是在浏览器使用微信支付，最后在集成支付的时候，需要用到两种支付方式：微信外浏览器使用H5支付(微信内使用会提示，请在微信外浏览器打开)，微信内浏览器使用公众号支付, 那么就需要用到一个判断方法。12345// 判断是否为微信浏览器export function isWechat() &#123; let userAgent = window.navigator.userAgent.toLowerCase(); return userAgent.indexOf(&apos;micromessenger&apos;) !== -1;&#125; H5支付相比公众号支付，H5支付需要的开发步骤要简单得多，不知道微信为什么要这么折腾自家浏览器。 第一步 在后台对微信统一下单下单参数详见‘微信统一下单文档’这里唯一需要注意就是签名算法： 将所有非空参数以URL键值对的方式，按照参数名ASCII码从小到大排序，拼接为字符串，注意大小写 将字符串尾部拼接&amp;key=商户密钥 将字符串使用MD5加密后转为大写 举个栗子：12345678910appid: wxqwer123456mch_id: 10086body: test// 按字典序排序参数appid=wxqwer123456&amp;body=test&amp;mch_id=10086// 添加keyappid=wxqwer123456&amp;body=test&amp;mch_id=10086&amp;key=key// MD5加密转大写F5D442C19378535AB235223241D76484 签名代码如下123456789101112131415161718192021222324252627282930// 生成签名，参数为数组public function MakeSign($data)&#123; //按字典序排序参数 ksort($data); $string = $this-&gt;ToUrlParams($data); //在string后加入key $string = $string . "&amp;key=" . $this-&gt;key; // 商家密钥 //MD5加密 $string = md5($string); //所有字符转为大写 $sign = strtoupper($string); return $sign;&#125;// 格式化参数格式化成url参数public function ToUrlParams($data)&#123; $buff = ""; foreach ($data as $k =&gt; $v) &#123; if($k != "sign" &amp;&amp; $v != "" &amp;&amp; !is_array($v))&#123; $buff .= $k . "=" . $v . "&amp;"; &#125; &#125; $buff = trim($buff, "&amp;"); return $buff;&#125; 对于签名算法的验证可以使用‘微信支付接口签名校验工具’ 之后需要用post方式将参数以xml的形式提交到微信统一下单接口https://api.mch.weixin.qq.com/pay/unifiedorder123456789101112131415// 将数组转换为xmlpublic function ToXml()&#123; $xml = &quot;&lt;xml&gt;&quot;; foreach ($this-&gt;values as $key=&gt;$val) &#123; if (is_numeric($val))&#123; $xml.=&quot;&lt;&quot;.$key.&quot;&gt;&quot;.$val.&quot;&lt;/&quot;.$key.&quot;&gt;&quot;; &#125;else&#123; $xml.=&quot;&lt;&quot;.$key.&quot;&gt;&lt;![CDATA[&quot;.$val.&quot;]]&gt;&lt;/&quot;.$key.&quot;&gt;&quot;; &#125; &#125; $xml.=&quot;&lt;/xml&gt;&quot;; return $xml;&#125; 当然，返回的数据也是xml格式，我们需要对其进行解析12345678public function FromXml($xml)&#123; //将XML转为array //禁止引用外部xml实体 libxml_disable_entity_loader(true); $this-&gt;values = json_decode(json_encode(simplexml_load_string($xml, 'SimpleXMLElement', LIBXML_NOCDATA)), true); return $this-&gt;values;&#125; 第二步 发起支付之后在下单成功后将微信返回的mweb_url支付跳转链接返回给前台，前台访问链接即可唤起微信客户端，中间页会先进行权限的校验和安全性检查，‘常见错误’这里可以通过给mweb_url添加redirect_url参数来设置回调页面虽然微信文档上说明的是默认的回调地址为支付发起的页面，但是经过实践表明对于SPA单页应用的识别很不友好，所以还是自己额外设置一下吧。1mweb_url += &apos;&amp;redirect_url=&apos; + encodeURIComponent(redirect_url) 一定要记得对url使用encodeURIComponent进行转码 所以说对于H5支付，前台需要进行的操作十分简单，请求后台接口后打开url即可123456789onWechatPay () &#123; this.$http.post('order/wxpay/create', &#123; // 后台下单api order: this.order &#125;).then(res =&gt; &#123; let url = res.data.data.mweb_url; url += '&amp;redirect_url=' + encodeURIComponent(redirect_url); // redirect_url为回调地址 window.location.href = url; &#125;)&#125; 第三步 处理通知接下来需要去处理微信支付成功后的通知，在统一下单时设置的notify_url，就是接收微信支付异步通知回调地址，微信会向该地址发送xml，类似123456&lt;xml&gt;&lt;appid&gt;wx123456&lt;/appid&gt;&lt;body&gt;H5支付测试&lt;/body&gt;&lt;out_trade_no&gt;10086&lt;/out_trade_no&gt; ……&lt;/xml&gt; 我们需要将得到的xml进行解析，转换为可用的数据，方法在上文有提到，拿到数据之后就可以为所欲为了，到这里H5支付的全部流程就算完成了 公众号支付这真的是个深坑，深不见底的深坑，相比H5支付直接使用链接打开，公众号支付首先多了一个openid的授权，而且需要使用微信浏览器自带的WeixinJSBridge或者weixin-js-sdk，虽然前者是微信官方文档上推荐的用法，但是实际用起来效果并不好，也可能是我的使用方法有问题，这里我选择使用weixin-js-sdk的chooseWXPay方法来发起支付。 第一步 网页授权获取openid使用公众号支付，即trade_type为JSAPI时，统一下单的openid参数是必填的，所以我们首先要做的就是通过微信网页授权拿到用户在公众号对应appid下的唯一标识openid。在进行这一步之前，首先需要检查授权回调域名是否设置正确(见上文准备工作)，确保无误后，在前台通过页面跳转拿到授权，具体可以查看‘微信网页授权‘1234567onWechatPay () &#123; // appId: 公众号appid // redirect_uri: 授权回调地址 // state: 需要传递的参数 // scope: snsapi_base 只获取openid，页面会直接跳转，snsapi_userinfo 会弹出授权页面，获取用户信息 let url = `https://open.weixin.qq.com/connect/oauth2/authorize?appid=$&#123;appId&#125;&amp;redirect_uri=$&#123;redirect_uri&#125;&amp;response_type=code&amp;scope=snsapi_base&amp;state=$&#123;state&#125;#wechat_redirect`;&#125; 授权完成后，页面将会来到的授权的回调地址，并且微信会将参数附加到地址上1redirect_uri/?code=CODE&amp;state=STATE 这里的code是之后用来获取openid的凭据，state是之前自己附加的参数 关于授权回调地址，建议新建一个页面来作为发起微信支付的中间页，避免支付页面的逻辑过于复杂 在回调页面拿到code值之后，需要再次通过一个get请求拿到openid的值，由于请求参数包含公众号的appsecret，建议这一步操作放在后台来完成1234567891011$code = $request['code'];// get_request是自己封装的发起get请求的方法，这里就不介绍了$result = get_request('https://api.weixin.qq.com/sns/oauth2/access_token', array( 'appid' =&gt; $wechat['appid'], 'secret' =&gt; $wechat['appsecret'], 'code' =&gt; $code, 'grant_type' =&gt; 'authorization_code',));return json_decode($result, true); 前台传递code值访问后台api，这样在得到了用户唯一标识openid后，就可以进行下单操作了 第二步 统一下单公众号支付的统一下单api完全可以复用之前H5支付的，增加了openid的参数由前台传递，签名方式也相同。 第三步 配置sdk关于weixin-js-sdk，具体可以查看‘说明文档’-&gt;微信网页开发-&gt;微信JS-SDK说明文档。接下来介绍一下config时需要用到的参数，建议由后台下单api返回12345678wx.config(&#123; debug: false, // debug 模式，开启后pc端以log，移动端以alert的形式提示信息 appId: appid, // appid，不解释 timestamp: timeStamp, // 10位时间戳，字符串格式，注意是10位，表示的是秒数而不是毫秒数，是字符串不是数字，小写！小写！小写！ nonceStr: nonce_str, // 随机字符串 signature: sign, // 签名，重点，下文会详细介绍 jsApiList: [&apos;chooseWXPay&apos;] // 需要用到的api列表&#125;); 又是签名，这个签名非常关键，我可是在这里卡了整整一天，这里的签名需要用到的参数有12341. noncestr // 注意 小写！小写！小写！config时是驼峰，这里是小写，而且要值保持一致2. timestamp // 注意保持一致，字符串格式3. url // 当前发起请求的url，需要在商家后台设置公众号授权域名至页面所在目录，而且对于spa单页应用非常不友好，官方文档上说明需要#号之前路径，但我实践发现并不行，需要完整路径才能签名成功4. jsapi_ticket // 公众号用于调用微信JS接口的临时票据，需要一个get请求获取到access_token，再一个get请求拿到 先来介绍一下如何获取到这个jsapi_ticket吧，我选择放在后台来请求这里需要注意的是，由于access_token的唯一性，在获取access_token之后，之前获取到的都会失效，所以需要把access_token储存在数据库，在7200s的有效期内，访问数据库取值，而不是重复请求。创建后台api，接受前台传递的timeStamp，nonceStr和url来获取签名。12345678910111213141516171819202122232425262728293031323334$timeStamp = $request['timeStamp'];$nonceStr = $request['nonceStr'];$url = $request['url'];// 获取access_tokenif ('判断是否已有未过期的access_token') &#123; // $access_token = 'ss';&#125;else &#123; $result = get_request('https://api.weixin.qq.com/cgi-bin/token', array( 'appid' =&gt; 'appid', 'secret' =&gt; 'secret', 'grant_type' =&gt; 'client_credential', )); $result = json_decode($result, true); $access_token = $result['access_token']; // 入库&#125;//获取jsapi_ticket$result = get_request('https://api.weixin.qq.com/cgi-bin/ticket/getticket', array( 'access_token' =&gt; $access_token, 'type' =&gt; 'jsapi',));$result = json_decode($result, true);$ticket = $result['ticket'];$data = [ 'jsapi_ticket' =&gt; $ticket, 'timestamp' =&gt; $timeStamp, 'noncestr' =&gt; $nonceStr, 'url' =&gt; urldecode($url), // 对于url前台转码，后台解码];return $this-&gt;makeSign($data, false); 比较坑的一点在于，这里的签名算法跟下单的签名算法不一样，使用sha1加密，而不是MD5加密，并且不需要添加key。123456789public function MakeSign($data)&#123; //按字典序排序参数 ksort($data); $string = $this-&gt;ToUrlParams($data); // sha1加密 $sign = sha1($string); return $sign;&#125; 前台访问api配置sdk即可, 需要在发起支付的页面调用config方法(url的变化会导致config失效)123456789101112131415161718import wx from 'weixin-js-sdk';// timeStamp我是由前台生成的 timeStamp = parseInt(new Date().getTime() / 1000).toString()async function wechatConfig (wechat, timeStamp) &#123; // wechat 为统一下单返回的数据, let result = await Vue.http.post('webpay/sign', &#123; timeStamp: timeStamp, nonceStr: wechat.nonce_str, url: encodeURIComponent(document.URL) &#125;); wx.config(&#123; debug: false, appId: wechat.appid, timestamp: timeStamp, nonceStr: wechat.nonce_str, signature: result.data.data, jsApiList: ['chooseWXPay'] &#125;);&#125; 常见的错误见‘官网文档’-&gt;微信网页开发-&gt;微信JS-SDK说明文档-&gt;附录5 常见错误,特别需要注意参数的大小写以及url 由于异步请求较多,建议使用 async await的方式 第四步 发起支付在sdk配置完成之后, 就可以使用其chooseWXPay方法来发起支付了, 先来介绍一下参数12345678910111213wx.chooseWXPay(&#123; timestamp: timeStamp, // 小写,其他同上 nonceStr: nonce_str, // 不解释 package: 'prepay_id=' + prepay_id, // prepay_id由统一下单接口返回的,注意提交格式 signType: 'MD5', // 默认为'SHA1',新版支付需要使用'MD5' paySign: sign, // 第三个签名了...下面介绍 success: function () &#123; // 支付成功回调 &#125;, cancel: function() &#123; // 取消支付回调 &#125;&#125;); 其他的参数就不多说了,主要讲一下这个签名吧,第三个签名了,无力吐槽, 签名方式和统一下单相同,需要添加商户key使用MD5加密,依旧放在后台完成12345678910111213$prepayid = $request['prepayid'];$timeStamp = $request['timeStamp'];$nonceStr = $request['nonceStr'];$data = [ 'appId' =&gt; $wechat['appid'], 'timeStamp' =&gt; $timeStamp, // 注意参数为驼峰大写 'nonceStr' =&gt; $nonceStr, 'package' =&gt; 'prepay_id='. $prepayid, // 注意了,和前台一样,需要添加prepay_id= 'signType' =&gt; 'MD5'];return $this-&gt;makeSign($data) 参数配置完成之后,调用方法,即可发起支付,还有一点要注意的是,需要在ready方法中触发123wx.ready(function () &#123; wx.chooseWXPay(...)&#125;) 由于wx.config的进程是异步的,只有在ready方法中才能保证config配置完成 第五步 处理通知同上，可以和H5支付使用相同的通知地址 最后总结一下, 嗯, 一共3个api, 向微信请求5次, 3个签名 网页授权, 前台直接get请求 获取openid, 后台请求 统一下单, 后台统一下单, 包含第一个签名 获取config签名, 后台请求获取access_token, 再请求获取jsapi_ticket, 第二个签名 获取支付签名, 第三个签名 分享一下这部分的源码‘链接’，密码： kugp]]></content>
      <categories>
        <category>经验总结</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>javascript</tag>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript的一些实用技巧(持续更新)]]></title>
    <url>%2F2018%2F06%2F01%2FjsKnack%2F</url>
    <content type="text"><![CDATA[整理一些自己觉得有用的js的技巧跟知识点，嘛，想到哪写到哪吧，毕竟我记性这么差，还这么懒。 变量交换值123var a = 'world', b = 'hello';[a, b] = [b, a]console.log(a, b) // hello world ES6的解构赋值算是我非常喜欢的一个功能了，允许按照一定模式，从数组和对象中提取值，对变量进行赋值。如果是两个数字交换值的话，还可以这么做：12345var a = 12, b = 2;a ^= b;b ^= a;a ^= b;console.log(a, b) // 2 12 这个东西就比较黑科技了，按位运算符异或^，将数字转为二进制进行按位比对，上面的计算步骤大概是(位数就不写全了)：123a = 12 ^ 2 = 1100 ^ 0010 = 1110 = 14;b = 14 ^ 2 = 1110 ^ 0010 = 1100 = 12;a = 14 ^ 12 = 1110 ^ 1100 = 0010 = 2; 快速取整12345console.log(~~47.11) // 47console.log(~~-12.88) // -12console.log(~~3) // 3console.log(~~'1.2') // 1console.log(~~NaN) // 0 按位取反运算符~，会先判断类型进行隐式转换，之后将数字原码转二进制之后进行取反，再取其补码，除符号位外取反再加1对于数字和字符串类型，执行两次后就可以快速实现一个取整的效果，其他类型会转换成0 转换数字12console.log(+'1') // 1console.log(+&#123;&#125;&#125;) // NaN 当进行运算时会隐式转换数字，所以使用+可以快速地转换数字 转换Boolean12console.log(!!1) // trueconsole.log(!!'') // false 二次取反不解释，简单粗暴 参数解构和字符串拼接123456789101112let person = &#123; name: "张三", age: 20&#125;function say (&#123;name, age&#125;) &#123; // let message = '大家好，我叫'+ name +'，我今年'+ age +'岁了'; let message = `大家好，我叫$&#123;name&#125;，我今年$&#123;age&#125;岁了`; console.log(message)&#125;say(person); // 大家好，我叫张三，我今年20岁了 在函数方法中使用参数解构可以更方便的获取数组/对象中的值。在拼接字符串时，在替换引号之后，可以使用${}将变量直接写入字符串中，相比于+拼接字符串更加灵活。 valueOf 和 toString抛开二者的基本作用不谈，作为对象和方法的隐式属性，有一些意想不到的效果12345678910111213141516var a = &#123; value: 0, valueOf: function () &#123; console.log('valueOf'); return this.value += 1; &#125;, toString: function () &#123; console.log('toString'); return this.value += 1; &#125;&#125;alert(a); // valueOf 1alert(a); // valueOf 2console.log(+a); // toString 3console.log(+a); // toString 4 可以发现，运算会触发对象的valueOf方法，取值会触发toString方法以上的写法，每次对于对象获取到的值都不同，在调用之后都会发生改变，于是就可以实现一个很有意思的效果。1console.log(a === 1 &amp;&amp; a === 2 &amp;&amp; a === 3); // valueOf valueOf valueOf true &amp;&amp;运算符也会触发valueOf，就能实现这么一个一眼看上去几乎不可能为true的表达式。12345678910111213function add (num) &#123; var sum = num; var _add = function (_num) &#123; sum += _num; return _add; &#125; _add.toString = function () &#123; return sum; &#125; return _add;&#125;console.log(add(1)(2)(3)) // 6 既然取值触发toString，那么就可以在这上面做一些文章了，将一个函数方法链式调用来计算所有参数和，最后在取值的时候使用toString方法拿到值。 Spread 扩展运算符ES6的扩展运算符...可以将一个数组转为用逗号分隔的参数序列123456function add(x, y) &#123; return x + y;&#125;let numbers = [4, 38];add(...numbers) // 42 合并数组123let arr1 = ['a', 'b'];let arr2 = ['c'];console.log([...arr1, ...arr2]); // ['a', 'b', 'c'] 数组&amp;对象克隆，拒绝浅拷贝12345let arr = [], obj = &#123;&#125;;// let newArr = Object.assign([], arr);// let newArr = JSON.parse(JSON.stringify(arr));let newArr = [...arr];let newObj = &#123;...obj&#125;; 取数组最大值/最小值123let arr = [4, 6, 55, 12, 21];console.log(Math.max(...arr)); // 55console.log(Math.min(...arr)); // 4 将字符串转为数组1console.log([...'hello']) // ['h', 'e', 'l', 'l', 'o'] 平铺多维数组，这里只列举二维的123let arr11 = [11, [22, 33], [44, 55], 66];let flatArr = [].concat(...arr);console.log(flatArr); // [11, 22, 33, 44, 55, 66] Set 数组去重12let unique = arr =&gt; [...new Set(arr)];console.log(unique(['h', 'e', 'l', 'l', 'o'])); // ['h', 'e', 'l', 'o'] ES6 提供了新的数据结构 Set。它类似于数组，允许存储任何类型的唯一值。Set 本身是一个构造函数，用来生成 Set 数据结构，使用 Set 将数组处理之后再将其转为数组，就可以实现简单的数组去重 生成随机字符串1Math.random().toString(32).substr(2) 生成结果类似于’n76ebcr9sg’这样的字符串，toString方法可以转换数字进制，32进制数字包含了a-z和0-9这些字符，在生成随机数转换32位后截取前两位的’0.’，就可以快速的生成一个随机字符串。 typeof12typeof null // objecttypeof new Array() // object 在使用typeof判断数据类型的时候，需要注意null的类型判断也是’object’（毕竟万物皆对象）由于js的基本类型没有数组类型，所以数组的typeof也是’object’，那么如何去区分数组和对象呢123456789let arr = [], obj = &#123;&#125; Array.isArray(arr) // trueArray.isArray(obj) // falsetypeof arr === 'object' &amp;&amp; !isNaN(arr.length)//truetypeof obj === 'object' &amp;&amp; !isNaN(obj.length)//falseObject.prototype.toString.call(arr) // [object Array]Object.prototype.toString.call(obj) // [object Object] instanceof123456new Number(1) instanceof Number // true 1 instanceof Number // falsenew String('hello') instanceof String // true'hello' instanceof String // false[] instanceof Array // true[] instanceof Object // true 在使用instanceof判断类型的时候也需要注意，instanceof只对对象实例生效，对于基本类型的验证都是false，而对于数组的类型判断，既是数组也是对象 在条件中使用 &amp;&amp; 及 || 进行短语判断123let foo = 10; foo === 10 &amp;&amp; doSomething(); // === if (foo === 10) doSomething(); foo === 5 || doSomething(); // === if (foo !== 5) doSomething(); 这种写法算是利用了&amp;&amp;和||的特性，起到了和if语句相同的效果。&amp;&amp;会执行所有的条件判断语句，||执行到true的时候就会短路掉之后的条件，不去执行。 变量属性名12345let key = 'hello', value = 'world';console.log(&#123; // &#123;hello: 'world'&#125; [key]: value&#125;&#125;) ES6允许使用变量来作为对象的属性。 浮点数计算123console.log(0.1 + 0.2) // 0.30000000000000004console.log((0.1 + 0.2).toFixed(1)) // 0.3console.log(0.1 * 10 + 0.2 * 10)/ 10) // 0.3 js的浮点数计算算是很烦人的一点了，转换二进制之后对于浮点数的识别很不友好，最简单的解决办法就是使用toFixed了，还有就是转换为整数之后再进行计算，当然还有其它的方法，封装好的工具包等，就不多介绍了。 获取出现次数当我们想要获取字符串中某个字符串出现的次数，比如ggasddghasdw中’a’出现的次数12let str = 'ggasddghasdw';console.log(str.split('a').length - 1) // 2 同理，对于数组元素也可以使用这样的方式12let arr = [1, 2, 3, 5, 3];console.log(arr.toString().split(3).length - 1) // 2 深拷贝对象使用ES6的方法可以更灵活的完成对象的深拷贝123456789// badconst original = &#123; a: 1, b: 2 &#125;;const copy = Object.assign(original, &#123; c: 3 &#125;); delete copy.a; // copy =&gt; &#123; b: 2, c: 3 &#125;// goodconst original = &#123; a: 1, b: 2 &#125;;const copy = &#123; ...original, c: 3 &#125;;const &#123; a, ...result &#125; = copy; // result =&gt; &#123; b: 2, c: 3 &#125; 未完待续]]></content>
      <categories>
        <category>经验总结</category>
        <category>实用技巧</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AutoHotkey禁用热键以及Electron中的使用]]></title>
    <url>%2F2018%2F05%2F28%2Fautohotkey%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;AutoHotkey是一个用来定义热键的脚本工具，可以通过编写脚本语言设置或者禁用热键。&nbsp;&nbsp;&nbsp;&nbsp;由于之前的Electron项目需要全屏显示，并且禁用掉包括Windows，Alt + Tab之类的热键，为了确保安全性，使用权限来控制应用程序的退出。首先来介绍一下需求： 全屏显示及注册快捷键(之前的electron文章中有介绍‘点击查看’) 禁用退出热键 electron启动时调用脚本，退出全屏时终止进程 退出权限验证 AutoHotkey关于AutoHotkey，这里不过多介绍，具体可以查看‘官网’; 安装首先需要做的是安装‘点击下载’ 使用简单来讲，创建一个完整的AutoHotkey脚本步骤 新建一个.ahk后缀的文件，用来编写脚本语言，可以直接运行 将其转换为.exe方便使用(可以使用Ahk2Exe.exe或其他工具进行转换) 和退出全屏有关的快捷键设置如下：12345LWin::returnRWin::return // windowsAlt::return!Tab::return // Alt + Tab^Esc::return // Ctrl + Esc 写入到ahk文件后启动脚本即可禁用相关键位。 Electron中调用首先我们需要找到electron的主进程文件src/main/index.js，可以看到主进程的启动方法1app.on('ready', createWindow); 好了，接下来要做的就是在createWindow方法中启动脚本，在自定义的退出方法中，终止脚本。这里我选择使用了node的‘child_process’中的exec方法，启动子进程通过命令行工具，启动脚本，相关代码如下：12345678910import &#123; exec &#125; from 'child_process';function toggleFullScreen (bol) &#123; if (bol) &#123; exec('.\\AutoHotkey.exe'); // 命令行启动脚本 &#125; else &#123; exec('TASKKILL /IM AutoHotkey.exe'); // 终止进程 &#125; mainWindow.setFullScreen(bol);&#125; 封装了一下切换全屏显示的方法，方便使用。 我将AutoHotkey的exe文件跟ahk文件放在了打包后的根目录，注意要使用.\\而不是./ 注册快捷键这里使用到了两个快捷键：F11全屏，Esc验证权限退出全屏写了两个方法进行了注册1234567891011121314function registerFull () &#123; globalShortcut.register('F11', () =&gt; &#123; toggleFullScreen(true); registerEsc(); // 由于退出全屏时注销了Esc，所以每次全屏都要注册一下 &#125;);&#125;function registerEsc () &#123; globalShortcut.register('ESC', () =&gt; &#123; if (mainWindow.isFullScreen()) &#123; // 判断是否为全屏 mainWindow.webContents.send('esc', true); // 向渲染进程发送信息，下文会有介绍 &#125; &#125;);&#125; 客户端交互关于这一部分，需要实现的功能为，当点击Esc键时，主进程通知渲染进程验证权限，在权限验证通过后，渲染进程通知主进程退出全屏显示。对于客户端（渲染进程）和主进程之前的通信，electron有相关的api： ‘ipcRenderer’渲染进程发送和接收消息 ‘ipcMain’主进程接收消息 ‘webContents’主进程发送消息 那么问题就好解决了12345678910111213141516// 渲染进程import &#123; ipcRenderer &#125; from 'electron';ipcRenderer.on('esc', () =&gt; &#123; // 接收主进程Esc事件触发 this.$refs.permissionDialog.show().then(() =&gt; &#123; // 权限验证通过 ipcRenderer.send('exit'); // 向主进程发送消息，退出全屏 &#125;)&#125;)// 主进程import &#123; ipcMain &#125; from 'electron';ipcMain.on('exit', () =&gt; &#123; globalShortcut.unregister('ESC'); // 注销Esc快捷键 toggleFullScreen(false); // 退出全屏&#125;); 这里之所以要注销Esc快捷键，是因为electron注册的是全局快捷键，会影响其他应用程序的操作，所以在推出时注销，F11全屏时再次注册 源码贴一下这部分相关的所有源码，首先是主进程的12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import &#123; app, globalShortcut, BrowserWindow, ipcMain &#125; from 'electron';import &#123; exec &#125; from 'child_process';let mainWindow;function createWindow () &#123; mainWindow = new BrowserWindow(&#123; height: 768, width: 1024, autoHideMenuBar: true, // 隐藏导航 webPreferences: &#123; webSecurity: false // 解决跨域，之前文章有介绍 &#125; &#125;); toggleFullScreen(true); // 默认全屏，注册快捷键 registerEsc(); registerFull(); …… ipcMain.on('exit', () =&gt; &#123; // 退出 globalShortcut.unregister('ESC'); toggleFullScreen(false); &#125;);&#125;app.on('ready', createWindow);function registerFull () &#123; // 注册F11全屏快捷键 globalShortcut.register('F11', () =&gt; &#123; toggleFullScreen(true); registerEsc(); &#125;);&#125;function registerEsc () &#123; // 注册Esc退出全屏快捷键 globalShortcut.register('ESC', () =&gt; &#123; if (mainWindow.isFullScreen()) &#123; mainWindow.webContents.send('esc', true); &#125; &#125;);&#125;function toggleFullScreen (bol) &#123; // 切换全屏显示 if (bol) &#123; exec('.\\AutoHotkey.exe'); &#125; else &#123; exec('TASKKILL /IM AutoHotkey.exe'); &#125; mainWindow.setFullScreen(bol);&#125; 注意，我这里只列举了相关的代码，主进程自身功能代码没有包含 渲染进程1234567891011121314151617181920212223242526import &#123; ipcRenderer &#125; from 'electron';export default &#123; components: &#123; 'PermissionDialog': require('./components/Widget/PermissionDialog.vue').default &#125;, created () &#123; ipcRenderer.on('esc', () =&gt; &#123; this.onExit(); &#125;) &#125;, methods: &#123; onExit () &#123; if (this.checkPermission()) &#123; //验证当前用户权限 ipcRenderer.send('exit'); &#125; else &#123; this.$refs.permissionDialog.show().then(() =&gt; &#123; // 权限验证 ipcRenderer.send('exit'); &#125;) &#125; &#125;, checkPermission () &#123; …… &#125; &#125;&#125;]]></content>
      <categories>
        <category>项目实例</category>
        <category>经验总结</category>
      </categories>
      <tags>
        <tag>AutoHotkey</tag>
        <tag>electron</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Electron-Vue项目记录]]></title>
    <url>%2F2018%2F03%2F13%2Felectron%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;最近开始基于electron-vue做一个桌面应用，因为是独立做的项目，也是我首次从搭建环境开始自己做项目开发，踩了很多坑，总结一下一些值得记住的东西吧。 简介&nbsp;&nbsp;&nbsp;&nbsp;首先简单介绍一下Electron吧。&nbsp;&nbsp;&nbsp;&nbsp;当用Electron启动一个应用，会创建一个主进程。这个主进程负责与你系统原生的GUI进行交互并为你的应用创建GUI（在你的应用窗口），所以你能把它看作成一个被 JavaScript 控制的，精简版的 Chromium 浏览器。&nbsp;&nbsp;&nbsp;&nbsp;Electron-Vue集成了vue-cli脚手架，项目环境同常规的vue项目大致相同。 安装作为vue-cli的一个模板，可以直接使用以下命令搭建12npm install -g vue-clivue init simulatedgreg/electron-vue my-project 跨域在后台没有设置Access-Control-Allow-Origin的情况下，浏览器对于跨域请求会出错1Response to preflight request doesn&apos;t pass access control check: No &apos;Access-Control-Allow-Origin&apos; header is present on the requested resource. Origin &apos;http://localhost:9080&apos; is therefore not allowed access. 我们可以在前台解决这个问题，取消浏览器对于非同源请求的限制，在初始化Electron的BrowserWindow模块中配置这样一个参数：1234// /src/main/index.jsmainWindow = new BrowserWindow(&#123; webPreferences: &#123;webSecurity: false&#125;,&#125;) webSecurity是什么意思呢？顾名思义，他是设置web安全性，如果参数设置为 false，它将禁用相同地方的规则 (通常测试服), 并且如果有2个非用户设置的参数，就设置 allowDisplayingInsecureContent 和 allowRunningInsecureContent的值为true。 （webSecurity的默认值为true） allowDisplayingInsecureContent表示是否允许一个使用 https的界面来展示由 http URLs 传过来的资源。默认false。allowRunningInsecureContent表示是否允许一个使用 https的界面来渲染由 http URLs 提交的html，css，javascript。默认为 false。 build空白npm run build:win32打包出来一片空白，几经波折之后在webpack.renderer.config.js中发现了以下代码123456plugins: [ …… nodeModules: process.env.NODE_ENV !== 'production' ? path.resolve(__dirname, '../node_modules') : false] 一脸懵比。。原来是node_modules没有加载上，于是就有了解决办法 打包之前修改环境为production 修改代码为 1nodeModules: path.resolve(__dirname, '../node_modules') 全屏显示1234567891011121314151617import &#123; app, globalShortcut, BrowserWindow &#125; from 'electron'mainWindow = new BrowserWindow(&#123; height: 768, width: 1024, autoHideMenuBar: true, webPreferences: &#123; webSecurity: false &#125;&#125;)mainWindow.setFullScreen(true)// mainWindow.setMenu(null)globalShortcut.register('ESC', () =&gt; &#123; mainWindow.setFullScreen(false);&#125;) 通过设置win.setFullScreen(true)全屏显示，ESC退出全屏 配置项autoHideMenuBar: true用来隐藏菜单栏，这样设置的话按Alt键会显示菜单，想要完全隐藏的话，可以设置win.setMenu(null) 注册快捷键global-shortcut 模块可以便捷的设置(注册/注销)各种自定义操作的快捷键，例如上面的ESC退出全屏，包含以下函数:1.globalShortcut.register(accelerator, callback) accelerator ‘accelerator’ callback Function快捷方式使用 register 方法在 globalShortcut 模块中注册, 即:12345678const &#123;app, globalShortcut&#125; = require('electron') app.on('ready', () =&gt; &#123; // Register a 'CommandOrControl+Y' shortcut listener. globalShortcut.register('CommandOrControl+Y', () =&gt; &#123; // Do stuff when Y and either Command/Control is pressed. &#125;) &#125;) 2.globalShortcut.isRegistered(accelerator)查询 accelerator 快捷键是否已经被注册过了,将会返回 true(已被注册) 或 false(未注册).3.globalShortcut.unregister(accelerator)注销全局快捷键 accelerator.4.globalShortcut.unregisterAll()注销本应用注册的所有全局快捷键. axios封装目的： 设置请求头 数据处理 添加loading 返回值验证 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import Vue from 'vue'import axios from 'axios'import qs from 'qs'import store from '../../store'import &#123;Loading&#125; from 'element-ui'let loading;// Add a request interceptoraxios.interceptors.request.use(function (config) &#123; showLoading(); config.url = 'http://xxxxxx' + config.url; config.headers['Content-Type'] = 'application/x-www-form-urlencoded'; config.headers['Authorization'] = localStorage.getItem('token'); if (config.method === 'post') &#123; config.data = qs.stringify(&#123; ...config.data &#125;) &#125; return config&#125;, function (error) &#123; return Promise.reject(error)&#125;)// Add a response interceptoraxios.interceptors.response.use(function (response) &#123; hideLoading(); if (response.data.error_code === '002') &#123; store.commit('_setOnlineStatus', false)// sign out &#125; else &#123; return response &#125;&#125;, function (error) &#123; hideLoading(); return Promise.reject(error)&#125;)function showLoading () &#123; loading = Loading.service(&#123; fullscreen: true, lock: false, text: 'Loading...' &#125;)&#125;function hideLoading () &#123; loading.close()&#125;Vue.http = Vue.prototype.$http = axios 这里使用的是axios提供的interceptors拦截器方法，对request和response进行了拦截。request: 添加loading，修改url，token，Content-Type，我在用户登录时，将token存在了localStorage中，并使用qs模块对post请求发送的数据进行了处理。response: 移除loading，当token过期时，退出登录，这里的退出功能使用了vuex来实现，在根组件监听onlineStatus的变化，当值为false时登出。。最后将axios注册在Vue实例的原型上，可以直接通过this.$http来调用。1this.$http.get('/list').then(res =&gt; &#123;&#125;).catch(() =&gt; &#123;&#125;); I18n多语言设置项目要求使用多语言，我选择使用了vue-i18n，配置如下：123456789101112131415161718import Vue from 'vue'import VueI18n from 'vue-i18n'import enLocale from 'element-ui/lib/locale/lang/en'import zhLocale from 'element-ui/lib/locale/lang/zh-CN'Vue.use(VueI18n);let locale = localStorage.getItem('locale');export const i18n = new VueI18n(&#123; locale: locale || 'zh-CN', // set locale silentTranslationWarn: true, messages: &#123; 'zh-CN': require('./zh-CN').default, 'en': require('./en').default &#125;&#125;);i18n.mergeLocaleMessage('zh-CN', zhLocale);i18n.mergeLocaleMessage('en', enLocale); 项目使用了Element-ui，所以需要导入语言包，后来发现Element-ui有方法导入多语言，就不需要再用mergeLocaleMessage进行合并，在main.js中引入时这样使用123456// 注意这里的i8n是上面语言配置文件导出的VueI18n实例import &#123; i18n &#125; from './lang'Vue.use(ElementUI, &#123; i18n: (key, value) =&gt; i18n.t(key, value)&#125;); 我选择将语言的配置存放在localStorage中，在每次切换语言后修改localStorage，记录当前所选择的语言，切换语言时调用12this.$i18n.locale = 'en';localStorage.setItem('locale', 'en'); 当然，在配置完成之后，还需要在main.js中实例化Vue的时候引入123456789import &#123; i18n &#125; from './lang';new Vue(&#123; components: &#123; App &#125;, router, store, i18n, template: '&lt;App/&gt;'&#125;) 以中文文件为例，为了方便管理，在’zh-CN文件夹下引入各个模块的语言文件12345678910111213// index.jsexport default &#123; 'table': require('./table').default, 'order': require('./order').default, 'indent': require('./indent').default, 'member': require('./member').default, 'report': require('./report').default, 'login': require('./login').default&#125;// login.jsexport default &#123; 'title': '登录'&#125; 使用方法:1&lt;div&gt;&#123;&#123; $t(&apos;login.title&apos;) &#125;&#125;&lt;/div&gt; //登录 在组件中，可以使用this.$i18n访问对象 登录超时项目要求无操作1分钟后退出登录，退出前有消息提示(这里需要吐槽一下1分钟这个时间)，话不多说，直接贴代码，我把登录超时验证的逻辑放在了与login.vue同级的full.vue根文件上，除登陆页之外的所有页面都注册在它的子路由下。12345&lt;template&gt; &lt;div class="full-page" @mousemove="onMouseMove"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;script type="text/javascript"&gt; import moment from 'moment'; export default &#123; data () &#123; return &#123; lastTime: null, // 上次操作的时间 showMessage: true // 防止重复弹出message box &#125; &#125;, created () &#123; if (!localStorage.getItem('token')) &#123; // 登录超时后刷新页面也会退出 this.onExit(); &#125; &#125;, mounted () &#123; this.checkTime(); &#125;, methods: &#123; onMouseMove () &#123; // 记录上次操作的时间 this.lastTime = moment(); &#125;, checkTime () &#123; this.lastTime = moment(); let timer = setInterval(() =&gt; &#123; let time = moment() - moment(this.lastTime); if (time &gt; 60000 &amp;&amp; this.showMessage) &#123; // 时间差大于一分钟 localStorage.removeItem('token'); this.showMessage = false; this.$alert(this.$t('login.errors.overtime_text'), this.$t('login.errors.overtime'), &#123; confirmButtonText: this.$t('confirm'), closeOnClickModal: true, callback: () =&gt; &#123; this.showMessage = true; clearInterval(timer); this.onExit(); &#125; &#125;) &#125; &#125;, 5000) &#125;, onExit () &#123; localStorage.removeItem('token'); this.$router.push('/login'); &#125; &#125; &#125;&lt;/script&gt; 其实道理很简单，给根页面绑定mousemove事件，记录上次操作的时间，然后启动定时器，判断当前时间差，超时之后弹出消息提示，这时候已经清掉了储存的token，已经算是退出登录了，在message box的回掉中退出到登陆页。 一定要清定时器！一定要清定时器！一定要清定时器！ Eslint 从入门到放弃之前提到Electron-Vue使用了vue-cli脚手架来搭建项目环境，在使用vue-cli安装时，可以选择直接安装eslint，如果想安装eslint到其他项目12npm install -g eslinteslint --init 全局安装eslint之后，在项目文件夹执行命令生成.eslintrc配置文件即可,下面来大致介绍一下 env: 脚本运行环境，如brower、node环境变量、es6环境变量、mocha环境变量等 globals: 额外的全局变量 rules: 开启规则和发生错误时报告的等级 规则的错误等级有三种：1230或&apos;off&apos;：关闭规则。1或&apos;warn&apos;：打开规则，并且作为一个警告（并不会导致检查不通过）。2或&apos;error&apos;：打开规则，并且作为一个错误 (退出码为1，检查不通过)。 默认配置的eslint有很多特(sang)别(xin)贴(bing)心(kuang)的地方，就不一一赘述了，我在开发的时候关闭了一些自己不能忍的规则1234567891011121314'rules': &#123; "no-unused-vars": [2, &#123; // 允许声明未使用变量 "vars": "local", // 参数不检查 "args": "none" &#125;], // 关闭语句强制分号结尾 "semi": [0], //空行最多不能超过100行 "no-multiple-empty-lines": [0, &#123;"max": 100&#125;], //关闭禁止混用tab和空格 "no-mixed-spaces-and-tabs": [0],&#125; 由于Eslint不允许使用未声明的变量，因此在使用全局变量的时候会出现no-undef的报错1&apos;axios&apos; is not defined 几番尝试之后发现这种东西似乎是关不掉的，于是只能在globals中添加允许的全局变量1234globals: &#123; __static: true, axios: true&#125; 对于使用webstrom / phpstrom的童鞋，想体验eslint的酸爽的话，需要手动开启vip体验Preferences -&gt; Languages &amp; Frameworks -&gt; JavaScript -&gt; Code Quality Tools -&gt; Eslint -&gt; Enable (勾选) -&gt; Apply -&gt; OK 当然，在使用vue-cli脚手架不小心安装了eslint的时候，直接在webpack的config配置文件中删除即可123456789101112131415module: &#123; rules: [ // &#123; // test: /\.(js)$/, // enforce: 'pre', // exclude: /node_modules/, // use: &#123; // loader: 'eslint-loader', // options: &#123; // formatter: require('eslint-friendly-formatter') // &#125; // &#125; // &#125;, &#125;&#125; Better-Scroll滚动封装因为是应用于pos机的桌面应用，很多地方就要考虑内容的滚动，这里使用了‘better-scroll’;具体的使用方法见官方文档，我在使用的时候并没有像官方文档那样封装scroll组件，因为项目不需要那么复杂的功能和配置，当然，也进行了简单的封装，用‘mixin’的形式调用方法。123456789101112131415161718192021222324252627282930313233343536// scroll.jsimport BScroll from 'better-scroll';export default&#123; data () &#123; return &#123; scroll: null &#125; &#125;, methods: &#123; initScroll (dom = this.$refs.wrapper, option) &#123; this.$nextTick(() =&gt; &#123; //等待dom元素加载完成 if (!this.scroll) &#123; this.scroll = new BScroll(dom, option || &#123; scrollbar: &#123; fade: true, interactive: false &#125; &#125;); this.scrollPullDown(); &#125; else &#123; this.scroll.refresh(); //刷新 &#125; &#125;) &#125;, scrollPullDown () &#123; //下拉事件 if (this.pullDown) &#123; this.scroll.on('scrollEnd', (&#123;x, y&#125;) =&gt; &#123; if (y === this.scroll.maxScrollY) &#123; this.onPullDown(); &#125; &#125;) &#125; &#125; &#125;&#125; 在配置option的时候只添加了滚动条，没有其他的配置，在vue文件中使用scroll时1234// html &lt;div class="scroll-wrapper" ref="wrapper"&gt; &lt;div class="content"&gt;&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617// jsimport scroll from '../../assets/js/scroll';export default &#123; mixins: [ scroll ] …… methods: &#123; queryData () &#123; axios.post('url', &#123;&#125;).then(() =&gt; &#123; this.initScroll(); &#125;).catch(() =&gt; &#123; this.initScroll(); &#125;) &#125; &#125;&#125; 注意设置wrapper样式 123456.scroll-wrapper&#123; overflow: hidden; position: relative(滚动条定位) margin: 0 -15px;(空出滚动条的位置) padding: 0 15px;&#125; 定义的scrollPullDown方法，为滚动对象绑定了一个下拉事件，当滚动区域下拉至底部时触发，我在这里把他应用于表格的分页加载，因为是桌面应用，没有使用传统的分页器，而是使用下拉来加载下一页使用，需要设置pullDown: true以及onPullDown方法使用。 最后发现better-scroll并不是适用于触屏PC，弃用了。。由于electron自带chrome，所以直接通过css修改了滚动条样式，使用原生滚动 1234.scroll-wrapper&#123; overflow: auto; &#125;::-webkit-scrollbar-track-piece&#123; background-color: $white-color; &#125;::-webkit-scrollbar&#123; width:5px; &#125;::-webkit-scrollbar-thumb&#123; background-color: rgba(0,0,0,.6); border-radius: 3px &#125; Table简易封装上文提到了，将table结合scroll，实现下拉刷新。123456789101112131415161718192021222324252627282930import scroll from './scroll';export default&#123; mixins: [ scroll ], data () &#123; return &#123; tableData: [], pullDown: true &#125; &#125;, mounted () &#123; this.queryTableData(); &#125;, methods: &#123; queryTableData () &#123; if (this.resource) &#123; this.$http.post(this.resource, this.parms).then(res =&gt; &#123; this.tableData = this.tableData.concat(res.data.data) this.initScroll('.el-table__body-wrapper'); &#125;) &#125; &#125;, onPullDown () &#123; this.parms.page++; this.queryTableData(); &#125; &#125;&#125; 贴上简易版本的代码，依旧使用mixin的方法，在组件中导入后，配置resource请求地址和params请求参数，绑定tableData为表格数据，下拉时请求下一页数据。在组件中也可以通过调用queryTableData方法刷新表格。 上面提到了弃用了better-scroll，这里自己写了一个touchend方法来控制刷新表格 1234567891011touchStart (ev) &#123; this.touchStartSite = ev.touches[0].pageY;&#125;,touchEnd (ev) &#123; let endSite = ev.changedTouches[0].pageY; let wrapper = document.getElementsByClassName('el-table__body-wrapper')[0]; let content = document.getElementsByClassName('el-table__body')[0]; if (wrapper.scrollTop === (content.clientHeight - wrapper.clientHeight) &amp;&amp; (this.touchStartSite - endSite) &gt; 50) &#123; this.onPullDown(); &#125;&#125;, 在el-table绑定事件，判断触摸滑动的位移等于内容差且滑动的垂直距离大于50px，前者是为了判断是否滑到底，后者是为了限制滑动最短距离，判断完成后加载下一页。 还有一种封装方式，将表格作为一个组件，内容作为slot插入进去，这样在将配置项传入组件之后就可以使用了，在表格配件较多情况下，感觉这种方法相比mixins更方便。 Sass预设相信用过bootstrap4的都会对它的样式预设印象深刻，特别是盒模型的样式预设，对于我这种习惯使用的人来说，已经是爱不释手了，为了减少项目打包的负担，没有使用bootstrap，就自己使用sass写了一套，发布成了一个npm包‘ly-sass’，部分代码如下12345678910111213141516171819202122232425262728293031// margin padding setting$directions: (l: left, r: right, t: top, b: bottom);@for $index from 0 to 10 &#123; .p-#&#123;$index&#125; &#123; padding: $index * 0.5rem !important; &#125; .m-#&#123;$index&#125; &#123; margin: $index * 0.5rem !important; &#125; @each $key,$value in $directions &#123; .p#&#123;$key&#125;-#&#123;$index&#125; &#123; padding-#&#123;$value&#125;: $index * 0.5rem !important; &#125; .m#&#123;$key&#125;-#&#123;$index&#125; &#123; margin-#&#123;$value&#125;: $index * 0.5rem !important; &#125; &#125;&#125;@for $index from -1 to 101 &#123; .w-#&#123;$index&#125;&#123; width: #&#123;$index&#125;% !important; &#125; .h-#&#123;$index&#125;&#123; height: #&#123;$index&#125;% !important; &#125; .font-#&#123;$index&#125;&#123; font-size: #&#123;$index&#125;px !important; &#125;&#125; 使用时类似12&lt;div class=&apos;m-0 pt-2 ml-1&apos;&gt;&lt;/div&gt; // margin: 0; padding-top: 1rem; margin-left: 0.5rem;&lt;div class=&apos;w-50 h-100 font-20&apos;&gt;&lt;/div&gt; // width: 50%; height: 100%; font-size: 20px; 这只是其中比较有代表性的，具体的代码就不贴了，其他的预设都类似这种写法。 读卡器由于项目需要刷卡登录，刷卡识别会员卡等功能，所以外连了一个读卡器跟扫码枪，而且是功能最基础的那种，甚至没有任何的事件或者回调。。在读卡的时候会在光标处打出识别的卡号。想要用这么个玩意实现刷卡登录。。。em。。苦思冥想好几天之后，发现这个读卡器是可以呗keydown事件捕获的，那么问题就在于，如何去区分扫码和正常的按键盘，最后的实现代码：123456789101112131415161718192021222324252627282930313233export let cardReader = &#123; data () &#123; return &#123; keyList: [], // 记录字符集 keyTime: null, // 记录上次键盘时间 card_sn: null &#125; &#125;, mounted () &#123; this.initCardReader(); &#125;, methods: &#123; initCardReader () &#123; let vm = this; window.onkeydown = e =&gt; &#123; if (e.timeStamp - vm.keyTime &gt; 50) &#123; vm.keyList = []; vm.card_sn = null; &#125; vm.keyTime = e.timeStamp; vm.keyList.push(e.key); &#125; &#125; &#125;, watch: &#123; keyList: function (val) &#123; if (val.length === 10) &#123; // 识别10位会员号之后执行回调 this.card_sn = val.join(''); this.readerCallback(); &#125; &#125; &#125;&#125;; 通过比较两次keydown事件的时间差，如果相隔时间超过50毫秒，清空keyList数组，在长度达到10位时(会员卡号为10位)，执行回调readerCallback。 由于用mixin的方式引入cardReader方法，在使用时发现当同一页面中有不同组件(dialog)中加载方法时，由于键盘事件是注册在window上的，会导致多个组件中只有一个能用，解决方式是在每个dialog弹出时重新调用initCardReader Iconfont图标很早就听说过‘Iconfont’的大名，这次自己当家作主的项目，终于有了应用的机会，在实际开发一段时间之后，觉得这个东西是真的好用啊，不需要导入更多图标库，不需要再为了找图标浪费时间，话不多说，下面来介绍一下这个犀利的图标库吧。在打开Iconfont网站之后，登录用户名(github账号即可)，查询到你想要的图标，点击加入购物车，然后点右上角的购物车打开，创建项目并添加图标到项目中，然后进入到项目页面在这里就可以看到项目图标库代码以及图标的代码，复制上面的代码，和iconfont的字体样式一同加入到项目中，这里列举三种使用方法 在线字体库直接复制图标库代码使用，项目开发过程中方便修改1234567891011121314151617@font-face &#123; font-family: iconfont; src: url(&apos;//at.alicdn.com/t/font_592912_662zcis5mcu6usor.eot&apos;); /* IE9*/ src: url(&apos;//at.alicdn.com/t/font_592912_662zcis5mcu6usor.eot?#iefix&apos;) /* IE6-IE8 */format(&apos;embedded-opentype&apos;), url(&apos;//at.alicdn.com/t/font_592912_662zcis5mcu6usor.woff&apos;) format(&apos;woff&apos;), /* chrome, firefox*/ url(&apos;//at.alicdn.com/t/font_592912_662zcis5mcu6usor.ttf&apos;) format(&apos;truetype&apos;), /* chrome, firefox, opera, Safari, Android, iOS 4.2+*/ url(&apos;//at.alicdn.com/t/font_592912_662zcis5mcu6usor.svg#iconfont&apos;) format(&apos;svg&apos;); /* iOS 4.1- */&#125;.iconfont&#123; font-family: iconfont !important; font-size:16px; font-style:normal; -webkit-font-smoothing: antialiased; -webkit-text-stroke-width: 0.2px; -moz-osx-font-smoothing: grayscale;&#125; 引用css文件在项目代码的Font Class选项中可以查看路径1&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;at.alicdn.com/t/font_611773_gnzu317r1jvvaemi.css&quot;&gt; 引入图标文件在项目图标库定义完成之后，可以直接使用项目代码中的字体地址下载字体文件，引入使用1234@font-face &#123; font-family: iconfont; src: url(assets/font/iconfont.ttf) // electron只需要兼容chrome即可&#125; 对于使用webpack的项目，在打包之后会存在字体文件缺失的情况，需要下载字体文件并且按照webpack的引用规则引入文件。 ok，这样就完成iconfont的设置了，复制上面的图标代码使用就可以了1&lt;i class="iconfont"&gt;&amp;#xe649;&lt;/i&gt; 每次添加新图标都需要更新图标库代码]]></content>
      <categories>
        <category>项目实例</category>
        <category>经验总结</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>electron</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用webAPI预览上传图片和调用摄像头]]></title>
    <url>%2F2018%2F03%2F01%2Fwebapi%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;最近有遇到这样的需求，在开发过程中也踩了很多的坑，所以记录一下自己最后找到的解决方法。 图片上传预览&nbsp;&nbsp;&nbsp;&nbsp;使用webAPI接口的FileReader方法来读取input file上传的图片信息。&nbsp;&nbsp;&nbsp;&nbsp;FileReader对象允许Web应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，使用 File 或 Blob 对象指定要读取的文件或数据。&nbsp;&nbsp;&nbsp;&nbsp;其中File对象可以是来自用户在一个input元素上选择文件后返回的FileList对象,也可以来自拖放操作生成的 DataTransfer对象,还可以是来自在一个HTMLCanvasElement上执行mozGetAsFile()方法后返回结果。 FileReader()构造函数方法，返回一个新构造的FileReader对象。 FileReader.readAsDataURL()开始读取指定的Blob中的内容。一旦完成，result属性中将包含一个data: URL格式的字符串以表示所读取文件的内容。 FileReader.onload处理load事件。该事件在读取操作完成时触发。 实现代码如下：123456789101112131415//html&lt;input id="fileBtn" type="file" onchange="upload();" accept="image/*"/&gt;&lt;img src="" id="img"/&gt;//jsvar upload = function()&#123; var file = document.querySelector('#fileBtn'), img = document.querySelector('#img'), reader = new FileReader(); file = file.files[0]; reader.readAsDataURL(file); reader.onload = function(e)&#123; img.setAttribute("src", e.target.result); &#125;;&#125;; 调用摄像头&nbsp;&nbsp;&nbsp;&nbsp;在做这个功能时，最早查到的是Navigator.getUserMedia()这个方法，而且对于这个方法介绍的也比较多，但是在查询MDN文档后发现，这个特性已经从Web标准中删除，但是目前仍有一些浏览器支持，而新版的API已经修改为MediaDevices.getUserMedia()方法，这就需要我们在使用的时候注意浏览器兼容性。&nbsp;&nbsp;&nbsp;&nbsp;MediaDevices.getUserMedia()方法提示用户允许使用一个视频和/或一个音频输入设备，例如相机或屏幕共享和/或麦克风。如果用户给予许可，就返回一个Promise 对象，MediaStream对象作为此Promise对象的Resolved状态的回调函数参数，相应的，如果用户拒绝了许可，或者没有媒体可用的情况下，PermissionDeniedError 或者NotFoundError作为此Promise的Rejected状态的回调函数参数。因此在使用时，我们需要在考虑兼容性的情况下对方法进行修改：123456789101112131415if (navigator.mediaDevices === undefined) &#123; navigator.mediaDevices = &#123;&#125;;&#125;if (navigator.mediaDevices.getUserMedia === undefined) &#123; navigator.mediaDevices.getUserMedia = function(constraints) &#123; var getUserMedia = navigator.webkitGetUserMedia || navigator.mozGetUserMedia; if (!getUserMedia) &#123; return Promise.reject(new Error('getUserMedia is not implemented in this browser')); &#125; return new Promise(function(resolve, reject) &#123; getUserMedia.call(navigator, constraints, resolve, reject); &#125;); &#125;&#125;window.URL = (window.URL || window.webkitURL || window.mozURL || window.msURL); 使用getUserMedia()必须保证安全的环境，也就是本地，localhost或者https协议下才可以运行，http无法使用 调用方法实现功能:1234567891011121314151617181920//html&lt;video src=""&gt;&lt;/video&gt;//jsfunction successFunc(stream) &#123; var video = document.querySelector('video'); if ("srcObject" in video) &#123; video.srcObject = stream &#125; else &#123; video.src = window.URL &amp;&amp; window.URL.createObjectURL(stream) || stream &#125; video.play();&#125;function errorFunc(err) &#123; alert(err.name);&#125;navigator.getUserMedia(&#123; audio: false, video: true,&#125;, successFunc, errorFunc);]]></content>
      <categories>
        <category>插件工具</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>webAPI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel+Vue开发环境搭建]]></title>
    <url>%2F2018%2F02%2F08%2Flaravel-vue%2F</url>
    <content type="text"><![CDATA[最近开始学习Laravel的开发，简单的记录一下Laravel集成Vue开发环境的搭建过程。需要准备 php &gt; 7.0 composer node &gt; 6.0 npm &gt; 3.0 安装Laravel方法参照‘Laravel中文文档’; 执行命令1composer create-project --prefer-dist laravel/laravel blog //blog为项目名 安装完成之后12cd blogphp artisan serve 启动本地开发服务器，默认是8000端口，访问localhost:8000或127.0.0.1:8000 安装Vuepackage.json中自带的有vue和bootstrap-sass等的配置，首先需要去安装它12npm installnpm install vue-router –save-dev 配置Vue在/resources/assets/js下新建Vue的挂载点App.vue123456789101112&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default&#123; &#125;&lt;/script&gt; 修改app.js，与Vue项目中的main.js类似1234567891011121314require(&apos;./bootstrap&apos;);window.Vue = require(&apos;vue&apos;);import Vue from &apos;vue&apos;import App from &apos;./App.vue&apos;import router from &apos;./router&apos;const app = new Vue(&#123; el: &apos;#app&apos;, router, components: &#123; App &#125;, template: &apos;&lt;App/&gt;&apos;&#125;); 新建路由文件，在js文件夹下新建router文件夹，配置路由信息123456789import Vue from &apos;vue&apos;import Router from &apos;vue-router&apos;Vue.use(Router)export default new Router(&#123; routes: [ //…… ]&#125;) 在resources/views目录下添加index.blade.php文件1234567891011121314151617&lt;!doctype html&gt;&lt;html lang=&quot;&#123;&#123; app()-&gt;getLocale() &#125;&#125;&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;title&gt;Laravel&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script src=&quot;&#123;&#123; mix(&apos;js/manifest.js&apos;) &#125;&#125;&quot;&gt;&lt;/script&gt;&lt;script src=&quot;&#123;&#123; mix(&apos;js/vendor.js&apos;) &#125;&#125;&quot;&gt;&lt;/script&gt;&lt;script src=&quot;&#123;&#123; mix(&apos;js/app.js&apos;) &#125;&#125;&quot;&gt;&lt;/script&gt; 在resources/routes/web.php中修改路由配置123Route::get(&apos;/&apos;, function () &#123; return view(&apos;idnex&apos;);&#125;); 在webpack.mix.js中修改123mix.js(&apos;resources/assets/js/app.js&apos;, &apos;public/js&apos;) .extract([&apos;vue&apos;, &quot;vue-router&quot;, &quot;axios&quot;]) .sass(&apos;resources/assets/sass/app.scss&apos;, &apos;public/css&apos;); 配置完成后执行npm run watch即可，配置服务器指向public/index.php访问]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>php</tag>
        <tag>vue</tag>
        <tag>laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JQuery pjax技术简介与示例]]></title>
    <url>%2F2018%2F01%2F22%2Fpjax%2F</url>
    <content type="text"><![CDATA[pjax是jquery的一个插件，它使用ajax和pushState两个技术改善用户的网页浏览体验。简单来说，它的作用就是可以在实现局部刷新的同时，记录浏览历史，能使用浏览器前进后退功能，浏览器的url也会跟随内容变化。 实现原理用户点击链接时，pjax拦截了a标签的默认跳转动作，使用发送ajax请求，之后将服务器返回的HTML片段插入更新区域，页面填充完毕后，使用pushState更新当前的URL。 pushStateHTML5在History里增加了pushState方法，这个方法会将当前的url添加到历史记录中，然后修改当前url为新url。当然这个方法只会修改地址栏的Url显示，但并不会发出任何请求。 pushState的使用方法：1history.pushState(state, title, url) state: 可以放任意你想放的数据，它将附加到新url上，作为该页面信息的一个补充。 title: 页面标题，目前浏览器支持不好。 url: 新url，也就是你要显示在地址栏上的url。 1history.replaceState(state, title, url) replaceState方法与pushState大同小异，区别只在于pushState会将当前url添加到历史记录，之后再修改url，而replaceState只是修改state和url，不添加历史记录。1window.onpopstate 一般来说，每当url变动时&amp;用户点击浏览器历史前进后退按钮 ，popstate事件都会被触发。但若是调用pushState来修改url，该事件则不会触发，因此，我们可以把它用作浏览器的前进后退事件。 生命周期点击pjax链接触发浏览器前进后退根据pjax的生命周期，可以在不同时间触发需要的时间，官方提供的可绑定的event函数如下：以添加loading为例，在pjax开始发送和完成之后执行，实现的代码如下：123456$(document).on('pjax:send', function() &#123; $('#loading').show()&#125;)$(document).on('pjax:complete', function() &#123; $('#loading').hide()&#125;) 配置使用上文提到过，pjax通常使用链接或者按钮来触发，通过使用ajax请求得到html片段，首先来写一个demo来简单的应用pjax。html12345678&lt;div id="container"&gt;jQuery.pjax分页&lt;/div&gt; &lt;ul class="pagination"&gt; &lt;li&gt;&lt;a href="data.php?page=1"&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="data.php?page=2"&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="data.php?page=3"&gt;3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="data.php?page=4"&gt;4&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="data.php?page=5"&gt;5&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; js1$(document).pjax('a', '#container'); php123&lt;?php $page = $_GET['page'];echo $page; 这样就可以实现，在点击a链接时，内容区显示对应的页数，并且url会修改为对应的href。 因为使用了ajax，所以需要配置服务器打开 上面的demo中使用了pjax的简单应用，接下来介绍一下详细的配置项与使用1$(document).pjax(selector, [container], options) selector 字符串，点击的对象选择器 container 字符串，选择唯一标识pjax容器。 options 下面所描述的一个对象。 举个栗子：12345678var pjaxoption = &#123; timeout: 10000, container: '.main_content', /* 内容替换的容器 */ cache: false, /* 是否使用缓存 */ storage: false, /* 是否使用本地存储 */ titleSuffix: '' /* 标题后缀 */&#125;;$(document).pjax('a', '#content', pjaxoption) 在配置项初始完成后还可以进行修改:1$.pjax.defaults.timeout = 1200 除此之外，pjax还有一些extend的方法来触发。123456789101112//$.pjax.click$(document).on('click', 'a[data-pjax]', function(event) &#123; var container = $(this).closest('[data-pjax-container]') var containerSelector = '#' + container.id $.pjax.click(event, &#123;container: containerSelector&#125;)&#125;)//$.pjax.submit$(document).on('submit', 'form[data-pjax]', function(event) &#123; $.pjax.submit(event, '#pjax-container')&#125;)//$.pjax.reload$.pjax.reload('#pjax-container', options)]]></content>
      <categories>
        <category>插件工具</category>
      </categories>
      <tags>
        <tag>jquery</tag>
        <tag>pjax</tag>
        <tag>pushState</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(转)前端构建工具的比较]]></title>
    <url>%2F2018%2F01%2F18%2F%E5%89%8D%E7%AB%AF%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[转自‘原文地址’,‘译者地址’ 在之前，人们习惯将脚本写在一起。 但时代已经改变，现在将JavaScript代码分开来可能是一个复杂的工作。 随着单页应用程序（SPA）的兴起，这个问题已经升级。他们倾向于依靠一些有用的系统（来解决这个问题）出于这个原因，有多种策略来加载它们。您可以立即加载它们，或者考虑需要它们时加载。Webpack支持许多这样的策略。 Node和npm的流行，给它的包管理器提供了更多的使用环境。在npm普及之前，很难使用依赖项。有一段时间，人们开发出了前端特定的包管理器，但npm最终赢得了胜利。现在依赖管理比以前更容易了，尽管还需要克服一些挑战。 任务运行程序与打包历史上，已经有很多构建工具。 Make可能是最着名的，它仍然是一个可行的选择。 专门的任务运行程序，如Grunt和Gulp，是专门为JavaScript开发人员创建的。 通过npm提供的插件使得任务运行程序都强大而且可扩展。 甚至可以使用npm脚本作为任务运行程序。 这很常见，特别是webpack。 任务运行程序是高水平的伟大工具。 它们允许您以跨平台方式执行操作。 当您需要将各种资源拼接在一起并生产时，问题就会开始。 出于此原因，存在资源整合程序，如Browserify，Brunch或webpack。 有一段时间，‘RequireJS’很受欢迎。 它的核心是提供一个异步模块的方法并建立在此之上。 AMD的格式在后面将会有更详细的介绍。 幸运的是，这些标准已经赶上了，而且RequireJS似乎是一个很好的启发。 Make就像1977年最初发布的那样，‘Make’回来了。尽管它是一个旧工具，但它仍然是相关的。 Make允许您为各种目的编写单独的任务。 例如，您可以有不同的任务来创建生产构建，压缩JavaScript或运行测试。 您可以在许多其他工具中找到相同的方法。 尽管Make主要用于C项目，但它并不以任何方式与C绑定。 James Coglan详细讨论了‘如何在JavaScript中使用Mark’。 看一下下面的詹姆斯帖子里介绍的压缩代码的方法： Makefile 1234567891011121314151617181920212223242526PATH := node_modules/.bin:$(PATH)SHELL := /bin/bash source_files := $(wildcard lib/*.coffee)build_files := $(source_files:%.coffee=build/%.js)app_bundle := build/app.jsspec_coffee := $(wildcard spec/*.coffee)spec_js := $(spec_coffee:%.coffee=build/%.js) libraries := vendor/jquery.js .PHONY: all clean test all: $(app_bundle) build/%.js: %.coffee coffee -co $(dir $@) $&lt; $(app_bundle): $(libraries) $(build_files) uglifyjs -cmo $@ $^ test: $(app_bundle) $(spec_js) phantomjs phantom.js clean: rm -rf build 使用Make，您可以使用Make-specific语法和终端命令为您的任务建模，使其可以与webpack集成。 RequireJS‘RequireJS’可能是第一个成为真正受欢迎的脚本加载程序。 它首先正确地引入了模块化JavaScript。 其最大的吸引力是AMD。 它引入了一个定义包装器： 12345678910define(['./MyModule.js'], function (MyModule) &#123; return function() &#123;&#125;; // 模块入口&#125;); // 或者define(['./MyModule.js'], function (MyModule) &#123; return &#123; hello: function() &#123;...&#125;, // 导出为模块函数 &#125;;&#125;); 顺便说一下，可以在包装器中使用require：12345define(['require'], function (require) &#123; var MyModule = require('./MyModule.js'); return function() &#123;...&#125;;&#125;); 后一种方法更简洁一点。 但您仍然会遇到多余的代码。 ES6等标准解决了这个问题。Jamund Ferguson撰写了一篇关于‘如何从RequireJS移植到webpack’的优秀博客系列。 之前有写过关于Require的博客‘RequireJS的使用’ npm脚本作为自动化构建工具即使npm CLI（命令行界面）并非主要用于作为任务运行的程序，由于有package.json的脚本字段是之成为可能。 考虑下面的例子： package.json 123456"scripts": &#123; "stats": "webpack --env production --json &gt; stats.json", "start": "webpack-dev-server --env development", "deploy": "gh-pages -d build", "build": "webpack --env production"&#125;, 这些脚本可以使用npm run列出，然后使用npm run script执行。 您还可以使用诸如test：watch这样的约定命名空间。 这种方法可以使它保持跨平台。 取代使用rm -rf，您可能更希望使用诸如rimraf等实用程序。 在这里可以调用其他自动化构建工具来隐藏你正在使用的具体细节。 这样，您可以在保持界面相同的情况下使用重构工具。 Grunt‘Grunt’在前端开发人员中是最受欢迎的。它的插件架构有助于它的流行，插件本身通常是复杂的，因此，当配置增加时，很难理解到底发生了什么。以下是‘Grunt文档的示例’。 在此配置中，您定义一个linting和一个观察任务。 当watch任务运行时，它也会触发lint任务。 这样，当您运行Grunt时，您可以在编辑源代码时在终端中实时发出警告。 Gruntfile.js 123456789101112131415161718192021module.exports = (grunt) =&gt; &#123; grunt.initConfig(&#123; lint: &#123; files: ['Gruntfile.js', 'src/**/*.js', 'test/**/*.js'], options: &#123; globals: &#123; jQuery: true, &#125;, &#125;, &#125;, watch: &#123; files: ['&lt;%= lint.files %&gt;'], tasks: ['lint'], &#125;, &#125;); grunt.loadNpmTasks('grunt-contrib-jshint'); grunt.loadNpmTasks('grunt-contrib-watch'); grunt.registerTask('default', ['lint']);&#125;; 在实践中，您将有许多小的任务用于特定目的，例如构建项目。 Grunt有用的一个重要部分是它隐藏了大量的细节。 从远来说，这可能会有问题。从Grunt的构建过程，你很难理解它引擎工作的具体情况。 ‘grunt-webpack’插件允许您在Grunt环境中使用webpack，同时将使用等级提升到Webpack。 Gulp‘Gulp’采取不同的方法。 您不需要依赖每个插件的配置，而是处理实际的代码。 Gulp建立在管道概念之上。 如果你熟悉Unix，这里也是一样的。 您需要遵循以下概念： 来源匹配文件。 对来源执行操作的过滤器（例如，转换为JavaScript） 接收模块库（例如，您的构建目录）在哪里管理构建结果。 这是一个示例的Gulpfile，可以让您更好地了解从项目的README中获取的方法。 它被缩写为一个接口： Gulpfile.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const gulp = require('gulp');const coffee = require('gulp-coffee');const concat = require('gulp-concat');const uglify = require('gulp-uglify');const sourcemaps = require('gulp-sourcemaps');const del = require('del'); const paths = &#123; scripts: ['client/js/**/*.coffee', '!client/external/**/*.coffee']&#125;; // 并不是所有的任务都需要使用流// 一个gulpfile是另一个节点程序// 你也可以在npm上使用所有的软件包gulp.task( 'clean', del.bind(null, ['build']); gulp.task( 'scripts', ['clean'], () =&gt; ( // 压缩和复制所有的JavaScript(除了供应商脚本) // 源代码一路下来 gulp.src(paths.scripts) // 管道内 .pipe(sourcemaps.init()) .pipe(coffee()) .pipe(uglify()) .pipe(concat('all.min.js')) .pipe(sourcemaps.write()) .pipe(gulp.dest('build/js')) )); // 文件更改时重新运行任务gulp.task( 'watch', gulp.watch.bind(null, paths.scripts, ['scripts'])); // 默认任务（从CLI运行`gulp`时调用）gulp.task( 'default', ['watch', 'scripts']); 鉴于配置是代码，如果遇到麻烦，您总是可以将其删除。 您可以将现有的节点包作为Gulp插件，等等。 与Grunt相比，您可以更清楚地了解发生了什么。 尽管如此，你仍然最终写了很多模板作为闲时任务。 那就是更新的方法。 ‘webpack-stream’允许您在Gulp环境中使用webpack。 ‘Fly’是与Gulp类似的工具。 它依赖于ES6发生器。 Browserify处理JavaScript模块一直是一个问题。 js语言本身没有模块的概念，直到ES6。 Ergo，这个语言在90年代被用在浏览器环境中。 已经提出了包括AMD在内的各种解决方案。‘Browserify’是模块问题的一个解决方案。 它可以将CommonJS模块捆绑在一起。 您可以将其与Gulp挂钩，您可以找到较小的转换工具，使您可以超越基本用法。 例如，watchify提供了一个在开发空闲的工作期间为您创建捆绑包的文件监视器。 Browserify生态系统由很多小模块组成。 这样，Browserify就符合Unix的理念。 Browserify比webpack更容易采用，实际上它是一个很好的替代品。 ‘Splittable’是一个Browserify包装器，允许代码分割，支持ES6开箱即用，Tree shaking等等。 JSPM使用‘JSPM’与以前的工具截然不同。 它附带了一个自己的命令行工具，用于将新的软件包安装到项目中，创建一个生产包，等等。 它支持‘SystemJS插件’，可以将各种格式加载到项目中。 Brunch与Gulp相比，Brunch在更高层次的抽象上运作。 它使用类似于webpack的声明方法。 以示例为例，您可以考虑从Brunch网站改编以下配置：123456789101112131415161718192021module.exports = &#123; files: &#123; javascripts: &#123; joinTo: &#123; 'vendor.js': /^(?!app)/, 'app.js': /^app/, &#125;, &#125;, stylesheets: &#123; joinTo: 'app.css', &#125;, &#125;, plugins: &#123; babel: &#123; presets: ['es2015', 'react'], &#125;, postcss: &#123; processors: [require('autoprefixer')], &#125;, &#125;,&#125;; Brunch包括像brunch new, brunch watch –server, and brunch build –production。 它包含了很多创造性的功能，可以使用插件扩展。 Webpack您可以说‘Webpack’采用比Browserify更单一的方法。 Browserify由多个小工具组成，而Webpack提供了一个核心，它提供了很多创造性的功能。Webpack核心可以使用特定的加载程序和插件进行扩展。 它可以控制如何解决模块，使您可以调整您的构建以匹配特定情况和解决无法正常运行的软件包。 与其他工具相比，Webpack具有初始复杂性，但通过其广泛的功能集成可以弥补这一点。 这是一个需要耐心的高级工具。 但是一旦了解了背后的基本思路，webpack就变得很强大。 结语历史上已经有很多JavaScript的构建工具。 每个人都试图以自己的方式解决一个特定的问题。 这些标准已经开始迎头赶上，基本语义的要求也更少了。 相反，工具可以在更高层次上竞争，并推动更好的用户体验。 通常，您可以一起使用几个单独的解决方案。 总的来说： 自动化构建工具和打包工具解决不同的问题。 您可以通过两者实现类似的结果，但通常最好将它们一起使用来相互补充。 较早的工具（如Make或RequireJS）仍然具有影响力，即使它们在前端开发中不如以往那样受欢迎。 Bundinner如Browserify或webpack解决了一个重要的问题，并帮助您管理复杂的Web应用程序。 一些新兴技术从不同的角度解决问题。 有时候它们建立在其他工具之上，有时它们可以一起使用。]]></content>
      <categories>
        <category>插件工具</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue项目中对EChart的应用]]></title>
    <url>%2F2018%2F01%2F16%2Fechart%2F</url>
    <content type="text"><![CDATA[EChart是目前一个应用较为广泛的图表工具，可高度个性化定制的数据可视化图表。由于项目中需要用到的图表比较多，这里简单的总结一下，使用面向对象的方法，定义chart类，来初始化&amp;更新图表，不喜欢面向对象封装的，可以直接看最下面。 安装1npm install echarts --save 定义chart类创建chart.js，这里要注意的是，必须引入所有需要用到的echart模块，可以按需引入的模块列表见‘EChart’12345678910111213141516171819202122232425import echarts from 'echarts/lib/echarts';import 'echarts/lib/chart/bar'；…… export default class Chart&#123; constructor(el)&#123; this.chart = echarts.init(el); //初始化，传入dom对象 this.options = &#123;&#125;; //配置项 &#125; show(op)&#123; this.options = _.assignIn(this.defaults, op); this.chart.clear(); this.chart.setOption(this.options); return this; &#125; resize()&#123; let chart = this.chart; window.onresize = function()&#123; chart.resize(); &#125; return this; &#125;&#125; 调用resize方法可以实现，随窗口改变刷新图表大小，在使用时需要保证图表自身是适应大小的，而不是固定的 应用chart创建图表类1234567891011121314import Chart from './Chart';export default class DemoChart extends Chart&#123; constructor(el, data) &#123; //dom对象和数据 super(el); this.data = data; &#125; get defaults() &#123; return &#123; //配置项options &#125; &#125;&#125; 关于配置项options，不过多介绍，详见‘EChart配置项手册’ 实例图表对象1234567891011&lt;div ref="chartInstance" class="w-100 h-100"&gt;&lt;/div&gt;……import DemoChart from './DemoChart';methods:&#123; initChart()&#123; let instance = this.$refs.chartInstance; let chart = new DemoChart(instance, this.data); chart.show().resize(); &#125;&#125; 这样一来一个实例化的chart就可以成功显示了，当我们需要更多chart时，只需要继续创建图标类，更改配置项就可以方便的添加更多种类的chart了。 简单粗暴的解决方法什么？面向对象？EXM？好吧，我也发现了，这么写虽然封装的比较完善，但是对于需求较少的项目，显得太过复杂，接下来说一下直接用的方式吧。1234567891011121314151617181920import * as echarts from 'echarts/lib/echarts';import 'echarts/lib/chart/line'// 引入各种需要的模块export function initChart (el, data) &#123; let myChart = echarts.init(el); setOption(myChart, data); return myChart;&#125;export function setOption (chart, data) &#123; let options = getOptions(data); chart.setOption(options)&#125;function getOptions (data) &#123; return &#123; // options &#125;&#125; 这里将init方法跟setOption分开写，是为了在数据变化时重新设置options，当然，直接再次初始化chart也可以。getOptions方法用来整理数据，由于项目只用到了一个chart，所以我直接写了一起，需要使用较多次的话，传参或者从其他文件引入吧。应用chart:123456789&lt;div ref="chartContent"&gt;&lt;/div&gt;import &#123; initChart, setOption &#125; from '../../assets/js/chart';if (!this.chart) &#123; this.chart = initChart(this.$refs.chartContent, this.report);&#125; else &#123; setOption(this.chart, this.report)&#125;]]></content>
      <categories>
        <category>经验总结</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>vue</tag>
        <tag>echart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue实例:文本隐藏提示组件]]></title>
    <url>%2F2017%2F12%2F13%2Fvue%E6%96%87%E6%9C%AC%E9%9A%90%E8%97%8F%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[项目需求模块内文本内容不超出时，正常显示，没有文本提示模块内文本内容超出容器宽度时，隐藏超出文本，hover时显示所有文本信息 需求分析 文本的隐藏，使用css样式控制 文字提示使用Element UI的tooltip组件 问题在于，既然是用css控制的文字隐藏，那么如何在vue文件中进行判断，因为组件的使用场景不同，而且容器宽度一般都是适应屏幕，在不能使用字符串长度进行判断的情况下如何确定文本是否超出。 功能实现 文本隐藏单行的文本隐藏，可以很简单的使用css来实现，多行的文本隐藏，目前我已知的样式中，只支持webkit内核，如果需要考虑兼容性，单纯的css可能无法实现 12345678910111213//单行.text-hidden &#123; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;&#125;//多行.text-multi &#123; display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 2; //限制为2行 overflow: hidden;&#125; 文本提示框使用‘Element UI Tooltip’组件 123&lt;el-tooltip effect="dark" content="提示文字" placement="top"&gt; &lt;el-button&gt;Tooltip&lt;/el-button&gt;&lt;/el-tooltip&gt; 显示判断对于控制tooltip的显示隐藏，使用el-tooltip自带的disabled属性。在鼠标移入组件时，使用 scrollWidth 和 offsetWidth 进行判断，当文本超出时，滚动区域的宽度会大于容器宽度。在多行的换行中，容器宽度一致，需要使用高度来进行判断。 代码(不含css) 1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;div :class="['tooltip-box', 'w-100', &#123;'h-100' : !multi&#125;]" @mouseenter="handleShowTooltip($event)"&gt; &lt;el-tooltip :disabled="showTooltip" :content="text" placement="top"&gt; &lt;div :class=" multi ? 'text-multi' : 'text-hidden'"&gt;&#123;&#123;text&#125;&#125;&lt;/div&gt; &lt;/el-tooltip&gt; &lt;/div&gt;&lt;/template&gt;&lt;script type="text/javascript"&gt; export default&#123; data()&#123; return &#123; showTooltip: false &#125; &#125;, props : &#123; text : String, // 切换 单/多行 multi: &#123; type : Boolean, default: false &#125; &#125;, methods: &#123; handleShowTooltip(event)&#123; let cell = event.target.querySelector('.el-tooltip'); this.showTooltip = cell.scrollWidth === cell.offsetWidth &amp;&amp; cell.scrollHeight === cell.offsetHeight; &#125; &#125; &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>项目实例</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>vue</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vuex简单入门]]></title>
    <url>%2F2017%2F11%2F28%2Fvuex%2F</url>
    <content type="text"><![CDATA[vuex是一个专门为vue.js设计的集中式状态管理架构，可用于数据的储存与组件之间的通信。 创建store每一个 Vuex 应用的核心就是 store（仓库）,在store中定义了存放数据的state和操作数据的方法。新建store.js文件并定义基础的store,这里存放了一个msg变量。12345export default&#123; state : &#123; msg : &apos;hi&apos; &#125;&#125; 注册store在创建store之后，首先需要注册store，在实例化vue对象时加入store,在store中引入vue和vuex12345678910111213//main.jsimport store from './store'new Vue(&#123; el: '#app', router, store, components: &#123; App &#125;, template: '&lt;App/&gt;'&#125;);//store.jsimport Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex); 除了全局注册外，还可以注册模块，注册方法为：registerModule( 模块名, 引入的store实例)123456789&lt;script type="text/javascript"&gt; import store from './store'; export default &#123; created: function () &#123; this.$store.registerModule('name', store); &#125; &#125;&lt;/script&gt; 注册store之后，在这个组件以及组件的所有子组件中，都可以直接调用store，不需要重复引入，因此store通常在根实例注册。 Statestate是vuex的核心概念之一，所有的数据都存放在state对象中，state中的数据需要使用计算属性获取，以上面定义的store为例，想要拿到定义的msg12345678computed : &#123; msg : function()&#123; //全局 return this.$store.state.msg //模块 return this.$store.state.name.msg //name为注册时的命名 &#125;&#125; Mutation更改 Vuex 的 store 中的状态的唯一方法是提交 mutation12345678910export default&#123; state : &#123; num : 0 &#125;, mutations : &#123; add(state, n)&#123; state.num += n &#125; &#125;&#125; 在mutation对象中定义的方法有两个参数，state对象和提交时传入的参数，需要在组件中提交mutation方法时1this.$store.commit('add', 1); 对于对象属性的赋值，建议使用Vue.set方法，确保可以监听到数据对象的变化，我在其他文章中有关于这一点的介绍‘Vue汇总’ Action通常异步操作和请求都是放在action中，此外，action中定义的方法可以通过commit mutation的方法来改变state中的数据。123456789101112131415export default&#123; state : &#123; num : 0 &#125;, mutations : &#123; _add(state, n)&#123; state.num += n &#125; &#125;， action : &#123; add( &#123;commit&#125;, n)&#123; commit('_add', n); &#125; &#125;&#125; 在action中定义的方法也有两个参数，第一个参数为当前的store对象，这里使用了参数解构的写法来获取到了param.commit，也可以写作123add( context, n)&#123; context.commit('_add', n);&#125; 在调用时，使用dispatch方法1this.$store.dispatch('add', 1); 1Vue.set(state, 'obj', data); Getter在从state中获取数据时，可能会需要进行数据的过滤或者格式化，getter的作用类似与计算属性12345678910111213export default&#123; state: &#123; names: [ &#123; id: 1, name : 'zhangsan' &#125;, &#123; id: 2, name : 'lisi' &#125; ] &#125;, getters: &#123; getNames: state =&gt; &#123; return state.names.map(item =&gt; item.name); &#125; &#125;&#125; 定义的getter会暴露为 store.getters 对象，获取方式类似state12345computed : &#123; names : function()&#123; return this.$store.getters.getNames //name为注册时的命名 &#125;&#125;]]></content>
      <categories>
        <category>插件工具</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP学习笔记:面向对象]]></title>
    <url>%2F2017%2F10%2F13%2Fphp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;类是对象的抽象，对象是类的实例&nbsp;&nbsp;&nbsp;&nbsp;提到面向对象，就会想起来这句话，印象中似乎大学考过不止一次，连我这个学渣都印象深刻 类的定义使用class关键字对类进行声明123456789101112//声明定义类class Task&#123; public $color = 'red'; public function say()&#123; echo 'hello'; &#125;&#125;//创建类的实例对象$task = new Task();echo $task-&gt;$color; //red$task-&gt;say(); //hello 构造函数与析构函数 构造函数 void __construct ([ mixed $args [, $... ]] )PHP 5 允行开发者在一个类中定义一个方法作为构造函数。具有构造函数的类在实例化对象时会调用这个方法。12345678910class Task&#123; public $color; public function __construct($color)&#123; $this-&gt;color = $color; &#125;&#125;//创建类的实例对象$task = new Task('red');var_dump($task-&gt;$color); //red 析构函数 void __destruct ( void )PHP 5 引入了析构函数的概念，析构函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行。 getter/settergetter/setter提供了一些属性读取的封装，可以让代码更便捷，使用方法限制对数据的随意赋值123456789101112131415class Task&#123; public $age; public function setAge($age)&#123; if($age &lt; 18)&#123; throw new Exception('not old enough'); &#125; $this-&gt;age = $age; &#125; public function getAge()&#123; return $this-&gt;age; &#125;&#125;$task = new Task();$task-&gt;setAge(30);var_dump($task-&gt;getAge()); //30 这里对age赋值小于18时就会报错，但是这样的封装还不够彻底，使用$task-&gt;$age可以不通过setter直接赋值，所以就需要用到类的封装 类的封装 public 公有，可以直接读取，修改和继承 private 私有，只能在类的内部访问到，直接读取会出错，不可以继承 protected 被保护，只能在类的内部访问到，直接读取会出错，可以继承 12345678910class Task&#123; private $age = 20; public function getAge()&#123; return $this-&gt;age; &#125;&#125;$task = new Task();var_dump($task-&gt;$age); //errorvar_dump($task-&gt;getAge()); //20 只能通过类内部的方法获取private和protected的属性 类的继承使用extends关键字，子类可以继承到所有的public和protected的属性和方法1234567891011121314class Mother&#123; protected function getEyesCount()&#123; return 2; &#125;&#125;class Child extends Mother&#123; public function getEyes()&#123; return $this-&gt;getEyesCount(); &#125;&#125;$child = new Child();var_dump($child-&gt;getEyes()); //2 抽象类 抽象类只能用来继承，不能直接调用 抽象类中的抽象方法，所有继承它的子类都必须定义，否则会报错 123456789101112131415161718192021abstract class Shape&#123; public $color = 'red'; abstract public function getArea();&#125;class Square extends Shape&#123; protected $length = 5; public function getArea()&#123; return pow($this-&gt;length,2); &#125;&#125;class Circle extends Shape&#123; //报错，没有定义getArea方法&#125;$shape = new Shape();var_dump($shape-&gt;color); //error$square = new Square();var_dump($square-&gt;color); //redvar_dump($square-&gt;getArea()); //25 对象接口 使用接口，可以指定某个类必须实现哪些方法，但不需要定义这些方法的具体内容 接口是通过interface关键字来定义的，类通过implements关键字调用接口 接口中定义的所有方法都必须是公有，这是接口的特性 接口也可以继承，通过使用extends操作符 12345678910111213141516171819202122232425262728293031interface Logger&#123; public function save($message);&#125;class FileLogger implements Logger&#123; public function save($message) &#123; var_dump('login in file '.$message); &#125;&#125;class DatabaseLogger implements Logger&#123; public function save($message) &#123; var_dump('login in database '.$message); &#125;&#125;class user&#123; protected $logger; public function __construct(Logger $logger) //使用Logger代替类名 &#123; $this-&gt;logger = $logger; &#125; public function register()&#123; $this-&gt;logger-&gt;save('jelly'); &#125;&#125;$user = new user(new FileLogger()); //更改这里的类的实例对象，就可以调用不同的save方法$user-&gt;register(); 接口中的定义的方法都是空的，跟抽象类一样，调用接口的类中必须定义这个方法，不然就会报错 这里需要补充一个php函数依赖注入的概念 1234567891011class C &#123;&#125;class D extends C &#123;&#125;class E &#123;&#125;function f(C $c) &#123; echo get_class($c)."\n"; //get_class 获取所在的类名&#125;f(new C); //Cf(new D); //Df(new E); //error 参数可以通过加类名来限制，只有这个类的以及继承了这个类的才有效，接口名同理，厉害了我的php 命名空间在PHP中，命名空间用来解决在编写类库或应用程序时创建可重用的代码如类或函数时碰到的两类问题： 用户编写的代码与PHP内部的类/函数/常量或第三方类/函数/常量之间的名字冲突。 为很长的标识符名称(通常是为了缓解第一类问题而定义的)创建一个别名（或简短）的名称，提高源代码的可读性。 1234567891011121314//文件1namespace app/test1class Task&#123; public function __construct() &#123; return 'hello'; &#125;&#125;//文件2$task = new app/test1/Task();# oruse app/test1$task = new Task(); 静态属性和静态方法使用static关键字定义静态属性和静态方法1234567class Math&#123; public static function add(...$num)&#123; return array_sum($num); &#125;&#125;echo Math::add(1,2,3); 调用静态方法时，可以不将类实例化为对象，直接调用方法12345678910111213class Person&#123; public static $age = 1; public function run()&#123; self::$age ++ ; &#125;&#125;$jack = new Person();$jack-&gt;run();echo Person::$age; //2$jane = new Person();$jane-&gt;run();echo Person::$age; //3 定义静态属性后，在类中使用self关键字调用 重新实例化person类并调用方法后，静态属性值并没有重置，说明静态属性的值与实例化对象无关，而是跟类相关，使用时需要注意 常量使用const关键字声明，在任何地方都不能改变，调用方式和静态属性相同1234class Task&#123; const num = 10;&#125;echo Task::num; Traitphp是单继承的语言，在PHP 5.4 Traits出现之前，PHP的类无法同时从两个基类继承属性或方法。php的Traits通过在类中使用use关键字声明要组合的Trait名称，而具体某个Trait的声明使用trait关键词，Trait不能直接实例化123456789101112131415161718192021trait Drive &#123; public $carName = 'trait'; public function driving() &#123; echo "driving &#123;$this-&gt;carName&#125;\n"; &#125;&#125;class Person &#123; public function eat() &#123; echo "eat\n"; &#125;&#125;class Student extends Person &#123; use Drive; public function study() &#123; echo "study\n"; &#125;&#125;$student = new Student();$student-&gt;study(); //study$student-&gt;eat(); //eat$student-&gt;driving(); //driving trait Student类通过继承Person，有了eat方法，通过组合Drive，有了driving方法和属性,实现了多继承 trait还有以下特点 当方法或属性同名时，当前类中的方法会覆盖 trait的 方法，而 trait 的方法又覆盖了基类中的方法 Trait 也能组合Trait，Trait中支持抽象方法、静态属性及静态方法]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue学习笔记:汇总]]></title>
    <url>%2F2017%2F10%2F12%2Fvue%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[记录一下一些简单但是有用的关于vue和node的知识点和问题 vue-cli构建项目 安装vue-cli 1npm install -g vue-cli 使用vue-cli初始化项目 1vue init webpack [project-name] //项目名 vue-cli 3.0版本增加了一个新命令来初始化项目，依赖node&gt;=8.91vue create [project-name] 安装依赖模块 12cd [project-name]npm install 开始运行 1npm run dev npm run命令在执行npm run xxx时,实际执行的是配置在package.json中的脚本12345"scripts": &#123; "dev": "node build/dev-server.js", "server": "node build/server.js", "build": "node build/build.js" &#125; 比如npm run dev执行时运行的是dev-server.js npm执行多个命令对于一般的命令，可以使用&amp;&amp;连接来顺序执行1'start' : 'npm run dev &amp;&amp; npm run server' 但是如果两条命令都是监听命令，第一个执行完之后便会停止，这时候可以使用concurrently模块首先需要安装npm install -g concurrently1"start":"concurrently \"npm run server\" \"npm run dev\"" 更改调试地址端口号在执行npm run dev后,会在localhost以测试环境运行项目,上文提到实际执行的是dev-server.js,查看之后发现以下代码12345var config = require('../config')// default port where dev server listens for incoming trafficvar port = process.env.PORT || config.dev.portvar uri = 'http://localhost:' + port 可见地址端口号即port的值,取的是环境变量的PORT或者config中定义的port值,找到../config/index.js,在module.exports的对象中的dev属性中，找到port的值，更改即可1234567dev: &#123; env: require('./dev.env'), port: 8080, autoOpenBrowser: true, …… cssSourceMap: false &#125; dependencies和devDependenciesdependences 是项目正常运行所需要的依赖，即生产环境，而devDependencies则是开发者开发时整个项目所需的依赖（如会有一些测试依赖之类的），及开发环境。1npm install 会默认安装两种依赖。 如果只想要安装devDependencies,则运行：1npm install name --save 如果只想要安装devDependencies,则运行：1npm install name --save-dev native原生事件现在在组件上使用v-on只会监听自定义事件 (组件提供的事件)。如果要监听根元素的原生事件，可以使用 .native 修饰符，比如给router-link绑定点击事件，element-ui组件绑定原生事件，如下:12345&lt;router-link :to="path" @click.native="click"&gt;&lt;el-input type="textarea" :rows="3" @keydown.enter.native="keydown"&gt;&lt;/el-input&gt; 动态组件通过使用保留的&lt;component&gt;元素，动态地绑定到它的is特性，我们让多个组件可以使用同一个挂载点，并动态切换：123456789101112&lt;component v-bind:is="currentView"&gt; &lt;!-- 组件在 vm.currentview 变化时改变！ --&gt;&lt;/component&gt;data: &#123; currentView: 'home'&#125;,components: &#123; home, posts, archive&#125; 可以通过切换绑定的属性，即currentView来切换不同的组件，或者动态的加载组件，currentView为null时组件会被销毁。如果想把切换出去的组件保留在内存中，可以保留它的状态或避免重新渲染。为此可以添加一个 keep-alive 指令参数。 keep-alive1234&lt;keep-alive&gt; &lt;coma v-if="bol"&gt;&lt;/coma&gt; &lt;comb v-else&gt;&lt;/comb&gt;&lt;/keep-alive&gt; 修改bol值切换组件加载时，这里的组件会被缓存起来，内容不会因为组件的切换而消失。此外，还有include和exclude属性：1234&lt;keep-alive include="coma" exclude="comb"&gt; &lt;coma v-if="bol"&gt;&lt;/coma&gt; &lt;comb v-else&gt;&lt;/comb&gt;&lt;/keep-alive&gt; 将会缓存组件coma，不会缓存comb。 watch数组/对象vue中使用watch可以监听数据的变化，但是对于数组或者对象内部的变化，直接watch是监听不到的，需要使用deep深度监听12345678watch:&#123; data: &#123; handler : function(newVal)&#123; //do something &#125;, deep : true &#125;&#125;, 监听路由变化$route 作为vue实例的一个响应式属性，是和data中定义的属性本质上是一样的，都可以通过this的方式拿到。既然可以使用watch监听data中的属性变化，同样也可以监听 $route 的变化。watch中监听的对象默认回调函数中的参数值就是newVal,oldVal，监听$route时的to,form也是这样。12345watch:&#123; '$route'(to, from)&#123; //... &#125;&#125; 使用sass安装依赖123npm install --save-dev sass-loader//sass-loader依赖于node-sassnpm install --save-dev node-sass 修改配置项，找到build文件夹下的webpack.base.config.js,修改其中的module.rules123456789module: &#123; rules: [ …… &#123; test: /\.scss$/, loaders: ["style", "css", "sass"] &#125; ]&#125; 在需要使用scss的地方，添加lang=&quot;scss&quot;1&lt;style lang=&apos;scss&apos;&gt;&lt;/style&gt; dirname与filenamenode.js中，在任何模块文件内部，可是使用__filename变量获取当前模板文件的带有完整绝对路径的文件名，使用__dirname可以获得当前文件所在目录的完整目录名。举个栗子，在test录下的test.js中12console.log(__dirname);console.log(__filename); 之后执行node test.js12D:\test\test.js //__dirnameD:\test //__filename mixinsmixins 选项接受一个混入对象的数组。这些混入实例对象可以像正常的实例对象一样包含选项，他们将在 Vue.extend()里最终选择使用相同的选项合并逻辑合并。这是官网对mixins的介绍，简单来讲，就是将对象合并进vue实例中，实现数据和方法的通用，举个栗子：123456789101112131415161718192021// mixin.jsexport default &#123; methods: &#123; sayHello () &#123; console.log(this.msg) &#125; &#125;&#125;// vueimport mixin from './mixin'export default &#123; data () &#123; return &#123; msg: 'Hello World' &#125; &#125;, mounted () &#123; this.sayHello(); // 'Hello World' &#125;&#125; 简单粗暴，通常用于通用逻辑的封装，相比引入函数方法，mixins对数据和方法的调用更加方便。1234567Vue.mixin(&#123; methods: &#123; sayHello () &#123; console.log(this.msg); &#125; &#125;&#125;); mixin也支持全局混合方法，不需要在导入，可以所有vue文件中直接使用。 变量声明出错1&lt;div&gt;&#123;&#123; _msg &#125;&#125;&lt;/div&gt; 12345data () &#123; return &#123; _msg: 'hello' &#125;&#125; 上面的代码在运行时会报错：1[Vue warn]: Property or method &quot;_msg&quot; is not defined on the instance but referenced during render 万万没想到这种基本操作也会出错，于是几经波折后找到了这句话 以 _ 或 $ 开头的属性或者方法不会被Vue实例代理，因为它们可能和 Vue 内置的属性、API 方法冲突。你可以使用例如 vm.$data._property 的方式访问这些属性 以上面的代码为例，如果非要使用下划线，可以通过this.$data._msg来获得属性值。 Vue.set在Vue文档中有这样一段话。 Vue 不能检测到对象属性的添加或删除。 由于 JavaScript 的限制，Vue 不能检测以下变动的数组： 当你利用索引直接设置一个项时，例如：vm.arr[index] = newValue 当你修改数组的长度时，例如：vm.arr.length = newLength1&lt;div&gt;&#123;&#123; user.age &#125;&#125;&lt;/div&gt; 123456789101112data () &#123; return &#123; user: &#123; name: '张三', sex: '男' &#125; &#125;&#125;,mounted () &#123; this.user.age = 20; console.log(this.user)&#125; 以上代码为user对象新增了age属性，但是会发现并没有触发dom的更新，页面显示的age依旧为空，这时候来看一下打印的结果：对于js对象，Vue在初始化时会遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter，再在看到上面的打印结果后，会发现对象中name及sex都有get和set方法,但是在age并没有这两个方法，因此，设置了age值后vue并不会自动更新视图，这时候就需要用到Vue.set方法。1this.$set(data, key, value); 在以上的例子中，使用的方法为1this.$set(this.user, 'age', 20); 打印结果如下： 错误路由页当路由跳转错误的时候，我们通常需要一个友好的页面来提示错误路由12345678&#123; path :'*', component: NotFound&#125;,&#123; path :'*', redirect: '/'&#125; 可以选择在路由配置的最下面这样定义，选择显示404页面或者重定向到主页 组件间的通信‘Vue学习笔记:组件之间的通信方式’ Echart使用‘Vue项目中对EChart的应用’ 实例‘Electron-Vue项目记录’‘Vue实例:文本隐藏提示组件’]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>vue</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP学习笔记:基础语法]]></title>
    <url>%2F2017%2F10%2F10%2Fphp%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[整理一下PHP入门的基础知识 一般语法&lt;?php #代码段 ?&gt;关键字，函数名，类，大小写不敏感变量大小写敏感默认文件扩展名为*.php通常包含HTML标签以及一些PHP脚本代码注释：//、#、/* ... */ 一致语法if…else if…else，switch-case，while，for12345678# foreach用法&lt;?php $colors = array("red","green","blue","yellow"); foreach ($colors as $value) &#123; echo "$value &lt;br&gt;";&#125;?&gt; 输出语句 echo 常用的输出语句，例如：echo ‘helloworld！’; print() 输出语句，有返回值。例如：print(‘helloworld！’); 输出成功返回1，失败返回0。 printf(); 格式化输出字符串。例如：printf(“%d,%f”,12,12.3); print_r(); 输出数组、对象等复合数据类型。例如：print_r($array); var_dump(); 可以判断一个变量的类型与长度,并输出变量的数值。例如：var_dump(‘helloworld！’); 常量常量类似变量，但是常量一旦被定义就无法更改或撤销定义。 自定义常量使用define()函数，它有三个参数 首个参数定义常量的名称 第二个参数定义常量的值 可选的第三个参数规定常量名是否对大小写不敏感。默认是 false。 1234&lt;?phpdefine("GREETING", "Welcome to W3School.com.cn!");echo GREETING;?&gt; 预定义常量 变量PHP 是一门类型松散的语言。我们不必告知 PHP 变量的数据类型。PHP能 根据它的值，自动把变量转换为正确的数据类型。 定义变量：$varName= varValue; //变量会在首次为其赋值时被创建取变量：$varName引用赋值：$str2 = &amp; $str1 变量命名规则变量以 $符号开头，其后是变量的名称变量名称必须以字母或下划线开头变量名称不能以数字开头变量名称只能包含字母数字字符和下划线变量名称对大小写敏感（y与Y 是两个不同的变量）变量会在第一次赋值时被创建。无需声明变量的类型。 变量作用域local（局部）函数内部声明的变量，作用域是所在函数，只能在函数内部进行访问1234567&lt;?phpfunction myTest() &#123; $y=10; # 局部作用域 echo '测试函数内部的变量：'.$y.'&lt;p&gt;'; # 测试函数内部的变量：10&#125;myTest();?&gt; global（全局）被函数之外声明的变量，作用域是整个php文件函数以外直接进行访问函数内使用global 关键词访问全局变量1234567891011&lt;?php$y=10;function myTest() &#123; global $y; # 函数内访问全局变量必须使用global 关键词 $y=10 + $y;&#125;myTest();echo $y; // 20?&gt; $GLOBALS[index]的数组中存储了所有的全局变量。下标存有变量名。这个数组在函数内也可以访问，并能够用于直接更新全局变量。12345678910&lt;?php$y=10;function myTest() &#123; $GLOBALS['y'] = 10 + $GLOBALS['y'];&#125; myTest();echo $y; // 输出 20?&gt; static（静态）加长变量的作用域可以在函数调用结束后仍保留变量值，当再次回到其作用域时，继续使用原来的值 可变变量允许动态改变一个变量名称,变量名是一个变量1234567&lt;?php$a = 'hello';$$a = 'world';echo "$a $&#123;$a&#125;"; //hello worldecho "$a $hello"; //hello world?&gt; 超级全局变量超全局变量是在全部作用域中始终可用的内置变量$GLOBALS：引用全局作用域中可用的全部变量$_SERVER：保存关于报头、路径和脚本位置的信息$_REQUEST：用于收集 HTML 表单提交的数据$_POST：用于收集提交method=”post” 的 HTML 表单后的表单数据。也常用于传递变量$_GET：也可用于收集提交 HTML 表单 (method=”get”) 之后的表单数据$_FILES：经由 HTTP POST 文件上传而提交至脚本的变量$_ENV：包含服务器端环境变量的数组$_COOKIE：通过HTTP cookie传递给当前脚本的变量的关联数组 数据类型四种标量类型：boolean（布尔型），integer（整型），float（浮点型，double），string（字符串）两种复合类型：array（数组），object（对象）两种特殊类型：resource（资源），NULL（无类型） 检测数据类型 转化类型 (boolean),(string),(integer),(float),(array),(object) 举个栗子 (boolean)$str 将变量转换为布尔型 settype ( mixed &amp;$var , string $type )1234567&lt;?php$foo = "5bar"; // string$bar = true; // booleansettype($foo, "integer"); // $foo is now 5 (integer)settype($bar, "string"); // $bar is now "1" (string)?&gt; 运算符运算符类型字符串运算符“.”：拼接字符串1echo "you " . "1" . '&lt;p&gt;'; “+”：只用于算术运算符【如果符号两边是字符类型-&gt;整型；字母-&gt;0；数字开头的字符串-&gt;截取数字】其他运算符一致 数组运算符注意：PHP中，数组的元素的顺序，不是由下标（键名）决定的，而是完全由加入的顺序来决定。 “+“：联结 将右边的数组项合并到左边数组的后面，得到一个新数组。如有重复键，则结果以左边的为准123$v1 = array(1, 2,3, 4);$v2 = array(5,6,7,8,9);$r1 = $v1 + $v2; //结果只能是：array(1,2,3,4,9) “==”： 相等，如果两个数组具有相同的键名和键值（可以顺序不同，或类型不同），则返回true12345$v1 = array(1, 2,3, 4);$v2 = array(4，2，1，3);$v3 = array(3=&gt;4，1=&gt;2，0=&gt;1，2=&gt;3);echo $v1 == $v2; //不等echo $v1 == $v3; //相等 “!=, &lt;&gt;” ：不相等，如果两个数组不是相等（==），则返回true“===”：全等，如果两个数组具有相同的键名和键值且顺序和类型都一样，则返回true“!==” ： 不全等，如果两个数组不是全等（===），则返回true 错误控制运算符：＠通常用于一个“可能”发生错误的表达式的前面——最常用的情形就是连接数据库。12$link = @mysql_connect(“localhost, ”’, “”,’”); var_dump($link); 或者更进一步的使用12$link = @mysql_connect(“localhost, ”’, “”,’”) or die("database link error"); var_dump($link); 通常错误控制运算符用在程序开发测试阶段无法预测的可能出错的位置——一般是获取外部资源的时候die是一种“语言结构”，并非函数，可以不写括号sleep($n);：让php脚本停止$n秒，然后继续执行。 运算符优先级优先级高的操作先执行同一优先级的操作从左到右执行赋值操作从右到左括号内先执行 函数一般函数1234567&lt;?phpfunction writeMsg() &#123; echo "Hello world!";&#125;writeMsg(); // 调用函数?&gt; 带参函数[值传参，引用传参]，参数默认值]12345678910111213&lt;?php$test = 1;function setSum($name,&amp;$quoteValue,$value=10) &#123; echo "$name sum is $value &lt;br&gt;"; $quoteValue = 100;&#125;echo $test.'&lt;br&gt;';setSum("width",$test);setSum("length",$test);setSum("high",$test);echo $test;?&gt; 带返回值函数123456789&lt;?phpfunction sum($x,$y) &#123; $z=$x+$y; return $z;&#125;echo "5 + 10 = " . sum(5,10) . "&lt;br&gt;";echo "7 + 13 = " . sum(7,13) . "&lt;br&gt;";?&gt; 变量函数类似于可变变量，将变量作为函数名12345678&lt;?phpfunction fn()&#123; echo 'hello';&#125;$str = 'fn';$str();?&gt; 函数引用使用变量引用函数，和参数引用传递不同，对函数的引用必须在两处都要用‘&amp;’，用来说明返回的是引用1234567&lt;?phpfunction &amp;rFun1($tmp = 0)&#123; return $tmp;&#125;$str = &amp;rFun1("god love you");echo $str.'&lt;br&gt;';?&gt; 取消引用unset()：取消引用，断开变量名和变量内容之间的绑定，并不销毁变量，也不改变原变量 数组数组类型索引数组 - 带有数字索引的数组123456789101112&lt;?php$cars=array("Volvo","BMW","SAAB");echo "I like " . $cars[0] . ", " . $cars[1] . " and " . $cars[2] . "."; # 索引下标$arrlength=count($cars); # 个数echo $arrlength; for($x = 0; $x &lt; $arrlength; $x++) &#123; # 遍历索引 echo $cars[$x]; echo "&lt;br&gt;";&#125;?&gt; 关联数组 - 带有指定键的数组12345678910&lt;?php# 第一种定义方法$age=array("Bill"=&gt;"35","Steve"=&gt;"37","Peter"=&gt;"43");# 第二种定义方法$age['Peter']="35";$age['Ben']="37";$age['Joe']="43";?&gt; 多维数组 - 包含一个或多个数组的数组123456789&lt;?php $cars = array ( array("Volvo",22,18), array("BMW",15,13), array("Saab",5,2), array("Land Rover",17,15) );?&gt; 常用数组操作获得数组元素个数int count(mixed array[, int mode])12$arr = array("Volvo",22,18);count($arr); 数组查询array_search()在数组中搜索给定的值，找到后返回键名，否则返回false。PHP4.2.0前，函数失败时返回nullmixed array_search(mixed needle, array haystack[, bool strict])needle指定在数组中搜索的值,haystack指定被搜索的数组,strict为true将检查给定值的类型常用于购物车中修改指定商品数量的修改和删除 获取数组中最后一个元素array_pop()获取并返回数组最后一个元素，并将数组长度减1，数组为空或类型不对，返回nullmixed array_pop(array array) 数组添加元素array_push()向数组末尾添加元素，返回新的总数int array_push(array array, mixed var[, mixed]) 数组删除重复元素array_unique()将数组元素的值作为字符串排序，对每个值只保留第一个键名，忽略所有后面的键名并不改变原数组，将删除重复元素的数组返回array array_unique(array array) 数组排序sort() - 以升序对数组排序rsort() - 以降序对数组排序asort() - 根据值，以升序对关联数组进行排序ksort() - 根据键，以升序对关联数组进行排序arsort() - 根据值，以降序对关联数组进行排序krsort() - 根据键，以降序对关联数组进行排序]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue学习笔记:组件之间的通信方式]]></title>
    <url>%2F2017%2F10%2F09%2Fvue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[在Vue中组件是实现模块化开发的主要内容，而组件的通信更是vue数据驱动的重点，总结一下目前我了解的组件之间数据通信和访问的方法。 v-bind和props父组件在子组件上使用v-bind绑定数据123&lt;div&gt; &lt;child :child-msg="msg"&gt;&lt;/child&gt; //这里必须要用 - 代替驼峰&lt;/div&gt; 12345data () &#123; return &#123; msg: 'hello' &#125;;&#125; 子组件通过props来接收数据1&lt;div&gt;&#123;&#123;childMsg&#125;&#125;&lt;/div&gt; //hello 1props: ['childMsg'] 可以通过使用this.childMsg调用数据。 自定义事件和$emit子组件要向父组件传递数据，需要使用触发事件的方式，使用$emit通知父组件改变数据1&lt;button @click='up'&gt;发送&lt;/button&gt; 12345678910data () &#123; return &#123; msg: 'hello' &#125;;&#125;methods: &#123; up () &#123; this.$emit('getChildMsg', this.msg); &#125;&#125; 父组件监听子组件触发的up事件,然后调用change方法123&lt;div&gt; &lt;child @getChildMsg="change"&gt;&lt;/child&gt;&lt;/div&gt; 12345methods: &#123; change(msg) &#123; console.log(msg); // hello &#125;&#125; v-model在介绍了props和$emit之后，就可以根据它们来实现在自定义组件上使用v-model来进行数据通信了。首先简单的解释一下v-model与二者的关系，以下两中写法实现的效果相同:12345678910// 使用v-model&lt;component v-model='msg'&gt;&lt;/component&gt;// 使用props和$emit&lt;component :value='msg' @input='getMsg'&gt;&lt;/component&gt;……getMsg(value)&#123; this.msg = value;&#125; 对于v-model绑定的变量，相当于在子组件上面绑定了一个value属性，还可以通过接收子组件传递的input属性来再次赋值。这么解释太抽象了，下面是一个简单的封装input组件的例子：父组件1&lt;my-input v-model=&apos;number&apos;&gt;&lt;/my-input&gt; 子组件123&lt;div&gt; &lt;input type=&quot;text&quot; v-model=&apos;inputValue&apos;&gt;&lt;/div&gt; 1234567891011121314151617181920212223&lt;script&gt; export default &#123; data () &#123; return &#123; inputValue: '' &#125; &#125;, props: &#123; value: [String, Number] // 拿到父组件传递的值 &#125;, mounted () &#123; this.inputValue = this.value; &#125;, watch: &#123; value: function (val) &#123; // 监听父组件传值变化，更新绑定值 this.inputValue = val; &#125;, inputValue: function (val) &#123; // 内容变化时，通知父组件 this.$emit('input', val); &#125; &#125; &#125;&lt;/script&gt; 路由传参在路由页面跳转时，可以通过传递参数的方式拿到数据。 router-link 12345678910111213141516&lt;router-link :to=&quot;&#123; path: &apos;/path&apos;, query: &#123; name: name &#125; &#125;&quot;&gt;&lt;/router-link&gt;&lt;router-link :to=&quot;&#123; name: &apos;/path&apos;, params: &#123; name: name &#125; &#125;&quot;&gt;&lt;/router-link&gt; 需要注意的是，path和query，name和params都是成对出现的，即使用path进行路由跳转时，params的值是拿不到的，只能设置query，反之亦然。params和query都可以传递，区别在于后者会出现在url上，考虑到刷新页面的情况，建议使用query $router方式 123456789101112this.$router.push(&#123; path: '/path', query: &#123; name: name &#125;&#125;)this.$router.push(&#123; name: 'name', //路由的name值 params: &#123; name: name &#125;&#125;) 参数的规则和router-link相同 获取参数的方式 对于使用params方式传递的参数1this.$route.params.name 对于使用query方式传递的参数1this.$route.query.name 动态路由匹配 在定义router时使用动态路径参数，以冒号开头12345const router = new VueRouter(&#123; routes: [ &#123; path: '/user/:id', component: User &#125; ]&#125;) 这时/user/foo 和 /user/bar 都将映射到相同的路由，在路由页面中获取：1this.$route.params.user props 路由传参 12345const router = new VueRouter(&#123; routes: [ &#123; path: &apos;/user/:id&apos;, component: User, props: true &#125;, ]&#125;) 将路由的props属性设置为true，在路由页就可以通过使用props拿到数据:1props: [&apos;id&apos;] 通过slot通信关于slot的使用就不介绍了，下面简单举个栗子123456789// 子组件&lt;div&gt; &lt;slot msg=&quot;hi&quot;&gt;&lt;/slot&gt;&lt;/div&gt;// 父组件&lt;child&gt; &lt;div slot-scope=&quot;scope&quot;&gt;&#123;&#123; scope.msg &#125;&#125;&lt;/div&gt; // hi&lt;/child&gt; 在slot插槽上绑定的数据可以通过slot-scope拿到，这里也支持解构的写法123&lt;child&gt; &lt;div slot-scope=&quot;&#123; msg &#125;&quot;&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt; // hi&lt;/child&gt; 设置中间件创建一个事件中心，相当于中间件，可以用它来传递事件和接收事件1var vm = new Vue(); 发送数据的组件触发1&lt;button @click="send"&gt;发送&lt;/button&gt; 12345methods: &#123; send() &#123; vm.$emit('change','hello'); &#125;&#125; 接收数据的组件12345created() &#123; vm.$on('change', (msg) =&gt; &#123; this.msg = msg; //hello &#125;);&#125; 在vue文件中需要使用中间件通信时，创建中间件，如下123import Vue from 'Vue';export default new Vue(); 使用时在组件中import导入即可 父组件访问子组件当我们需要在父组件中访问子组件时，可以使用$children或者$ref123456789101112//子组件1data () &#123; return &#123; msg: '这是子组件1的信息' &#125;&#125;//子组件2data () &#123; return &#123; msg: '这是子组件2的信息' &#125;&#125; $children返回所有子组件的实例，是一个数组 123&lt;div&gt; &lt;button @click="showmsg"&gt;显示子组件信息&lt;/button&gt;&lt;/div&gt; 1234567methods: &#123; showmsg () &#123; for(var i = 0; i &lt; this.$children.length; i++) &#123; console.log(this.$children[i].msg) &#125; &#125;&#125; 使用ref为子组件指定一个索引ID,可以在父组件使用$refs访问到 12345&lt;div id="count"&gt; &lt;button @click="showmsg"&gt;显示子组件信息&lt;/button&gt; &lt;child1 ref='c1'&gt;&lt;/child1&gt; &lt;child2 ref='c2'&gt;&lt;/child2&gt;&lt;/div&gt; 123456methods: &#123; showmsg () &#123; console.log(this.$refs.c1.msg) console.log(this.$refs.c2.msg) &#125;&#125; 在调用子组件方法时，可以通过传参的方式把数据传到子组件 123456//父组件this.$refs.child.show('hi')//子组件show(msg)&#123; this.msg = msg //hi&#125; Promise方式子组件中定义父组件需要调用的方法，并返回一个promise对象1234567891011121314151617181920data () &#123; return &#123; msg : 'hello', promise : &#123; resolve: null, reject : null &#125; &#125;&#125;methods: &#123; show() &#123; return new Promise((resolve, reject) =&gt; &#123; this.promise.resolve = resolve; this.promise.reject = reject; &#125;); &#125;, send () &#123; this.promise.resolve(this.msg); &#125;&#125; 调用send方法时，执行promise的resolve方法，向父组件返回msg，父组件调用show方法拿到返回值1&lt;child ref="child"&gt;&lt;/child&gt; 1234//调用的方法中this.$refs.child.show().then(result =&gt; &#123; console.log(result) //hello&#125;); result就是子组件返回的数据，即msg Vuex将数据存放在store中，另一组件获取state中的数据，或者watch state中数据的变化，来进行相应的操作‘Vuex简单入门’ 子组件访问父组件在子组件中使用$parent可以获取到父组件的对象，使用方法同$children 访问根组件使用$root可以获取当前组件树的根Vue实例。如果当前实例没有父实例，此实例将会是其自已]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记录贴:那些年踩过的坑]]></title>
    <url>%2F2017%2F09%2F30%2F%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[记录一下遇到的问题和解决方法，我有预感，这一篇会很长。 表单提交不刷新页面1234&lt;form id="myForm" method="post" target="formsubmit"&gt; ……&lt;/form&gt;&lt;iframe name="formsubmit" class="hide"&gt;&lt;/iframe&gt; form表单提交到iframe里面处理，而这个iframe是隐藏的，所以提交表单的时候当前页面没有发生任何变化。form的target属性指向iframe的name值，这样就实现了提交到隐藏的iframe中。提交时使用js提交1$('#myForm').attr('action', url).submit(); 也可以通过设置target=”_blank”在新页面提交表单 ie8 ajax请求无效设置1$.support.cors = true $.support.cors判断浏览器是否支持跨域访问，在ie8中默认值是false，需要手动开启 dataTables中文配置12345678910"language" : &#123; "paginate" : &#123; "next" : "下一页", "previous": '上一页' &#125;, "lengthMenu": "显示 _MENU_ 条/页", "info" : "共_TOTAL_条记录", "infoEmpty" : "共0条记录", "emptyTable": "没有查询到数据"&#125; dataTables数据为空时报错在配置columns时加上defaultContent:&#39;&#39; select默认选中第一个1$("select option:first").prop("selected", "selected"); checkbox的值checkbox不能通过val()拿到值，需要判断checked属性12$(&apos;input[type=&quot;chekcbox&quot;]&apos;).attr(&apos;checked&apos;, true) //选中$(&apos;input[type=&quot;chekcbox&quot;]&apos;).removeAttr(&apos;checked&apos;) //取消选中 ie8设置固定定位和透明1234567position: fixed;_position: absolute;_clear: both;_top:expression(eval(document.compatMode &amp;&amp; document.compatMode=='CSS1Compat') ? documentElement.scrollTop +(documentElement.clientHeight-this.clientHeight) - 1 : document.body.scrollTop +(document.body.clientHeight-this.clientHeight) - 1);opacity: 0;-ms-filter:"alpha(opacity=0)"; 设置表单不可选表单元素自带的有两个属性readonly和disabled，都可以设置内容无法改变 disabled 在ie9以下浏览器中，字体颜色会变得十分浅，只能用readonly 设置disabled,disabled=&quot;true&quot;和disabled=&quot;false&quot;都会生效，所以想要取消disabled属性，需要写1$('input[disabled]').removeAttr('disabled'); readonly对于select生效，但是因为select本身就是readonly的，依旧可以改变所选项，如果希望select不可改变12345$('select[readonly]').focus(function () &#123; this.defaultIndex = this.selectedIndex;&#125;).change(function () &#123; this.selectedIndex = this.defaultIndex;&#125;) input回车切换焦点这里必须先吐槽一句了，你老老实实用Tab键不行么?我#￥！@#！123456789$('body').on('focus', 'input', function () &#123; var input = $('input'); input.unbind('keydown'); input.keydown(function (ev) &#123; if (ev.keyCode == 13) &#123; input.eq(input.index(this) + 1).focus(); &#125; &#125;)&#125;); 因为有动态生成的input标签，所以这里把事件绑在了body上，focus时获取所有input的对象集合，回车切换到下一个。 在绑定keydown事件之前一定要先解绑，不然会重复绑定，然后执行2，4，8，16……别问我为什么知道，我浏览器就是这么卡死的。 表单提交对象1$('input').val(JSON.stringify(&#123;a:1&#125;) 数组在赋值的时候会自动转化成字符串 [1,2,3] =&gt; 1,2,3，对象直接赋值会显示object，需要转换一下格式，跟localStorage一个道理，后台拿到字符串后转为JSON格式即可。 git clone 403git clone和push的时候碰到403的错误，用户权限不足，，在地址前加上用户名跟密码即可123https://[用户名]:[密码][地址]//for examplehttps://liyu:123@github.com/gitliyu/gitliyu.github.io.git 事件委派的重复绑定在使用jquery对于一些动态生成的dom元素进行事件绑定时，通常需要绑定在父级上进行委派，常用的方法12345678910//对a链接添加点击事件$('body').click(function(e)&#123; if(e.target.tagName == 'A')&#123; ... &#125;&#125;)$('body').on('click', 'a', function()&#123; ...&#125;) 第二种方式当然是没有问题的，在使用第一种方式时，由于比较懒，直接把事件绑在了body而非父级上，在页面局部刷新时(jquery load或pjax)，由于body没有刷新而模板页的js文件重新执行，会出现事件重复绑定,需要在每次绑定事件前解绑1$('body').unbind(); 感觉这个问题出现的太过巧合，除了我估计也没人遇到了 target和currentTarget以点击事件为例，target指的是点击的dom对象，可以用来委派事件&amp;判断点击对象，currentTarget指的是所点击的绑定该点击事件的dom对象，防止事件冒泡和默认事件的组织。举个栗子：123456789&lt;li onclick="fn(e)"&gt; &lt;a href="###"&gt;link&lt;/a&gt;&lt;/li&gt;&lt;script type="text/javascript"&gt; function fn(e)&#123; console.log(e.target.tagName); console.log(e.currentTarget.tagName); &#125;&lt;/script&gt; 在以上代码中，点击a标签时，会分别输出12ALI 富文本编辑器过滤标签在使用富文本编辑器时，为了保留格式，直接使用v-model取得的value值都带有html标签，在项目中使用到的vue-quill-editor，虽然有提供获取纯文本的方法，但是默认的返回值为”\n”，一个换行符，并且仍然会有部分标签，无法进行非空判断。解决方法：1text = text.replace(/(&lt;[^&gt;]*&gt;|&lt;\/[^&gt;]*&gt;|\s+)/gm, ''); 过滤掉字符串中的html标签和空格 隐藏input number的按钮12345input::-webkit-outer-spin-button,input::-webkit-inner-spin-button &#123; -webkit-appearance: none !important; margin: 0;&#125; 减法出现小数js对于浮点型不够准确，因此在计算浮点数的减法时经常出现问题1console.log(171.2 - 85) // 86.19999999999999 解决方法： parseInt(), Math.Floor(), Math.Round()等方法取整，不常用 toFixed(2), 保留有效位数 扩大倍数之后在进行减法计算，既然浮点型运算有问题，那就换成整型来计算 12console.log((171.2 - 85).toFixed(1)) // &apos;86.2&apos;console.log((171.2 * 10 - 85 * 10) / 10) // 86.2]]></content>
      <categories>
        <category>经验总结</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Crypto-JS加密]]></title>
    <url>%2F2017%2F09%2F21%2FCrypto-JS%E5%8A%A0%E5%AF%86%2F</url>
    <content type="text"><![CDATA[CryptoJS (crypto.js) 为 JavaScript 提供了各种各样的加密算法。目前已支持的算法包括： MD5 SHA-1 SHA-256 AES等，这里以AES和base64为例简单介绍一下使用方法。 下载安装Node.js1npm install crypto-js 官网地址‘https://code.google.com/p/crypto-js’这个地址是需要翻墙才能下载 github‘https://github.com/brix/crypto-js’ 这里要提到的是，官网和github下载的文件略有差异，首先介绍官网下载的压缩包，分为rollups和 components两个文件夹。 rollups下面是整合后的js，每一个可以单独通过js引用使用。 componets下面刚包括所有的组件源码，以及各组件压缩后的js文件。 以AES为例：12345&lt;script src="rollups/aes.js"&gt;&lt;/script&gt; //or&lt;script src="components/core.js"&gt;&lt;/script&gt;&lt;script src="components/cipher-core.js"&gt;&lt;/script&gt;&lt;script src="components/aes.js"&gt;&lt;/script&gt; github上的js文件，和官网的components文件夹相同 使用依赖node.jsnpm安装后12var SHA256 = require("crypto-js/sha256");console.log(SHA256("Message")); 官方文档和github都有详细说明，这里不过多介绍。 引入js文件 aes 使用aes加密时，首先要定义密钥与盐12var key = CryptoJS.enc.Utf8.parse("5DquhGQAB9xdRUSp"); //密钥var iv = CryptoJS.enc.Utf8.parse("szWDBBzTYBQX2apH"); //盐 由前台或者后台随机生成，之后定义加密和解密的方法1234567891011//加密function Encrypt(word) &#123; var srcs = CryptoJS.enc.Utf8.parse(word); var encrypted = CryptoJS.AES.encrypt(srcs, key, &#123;iv: iv&#125;); return encrypted.toString();&#125;//解密function Decrypt(word) &#123; var decrypt = CryptoJS.AES.decrypt(word, key, &#123;iv: iv&#125;); return decrypt.toString(CryptoJS.enc.Utf8);&#125; base64 base64加密和md5加密方式类似，直接调用加密即可12345678910//加密function EncryptBase64(word)&#123; var str = CryptoJS.enc.Utf8.parse(word); return CryptoJS.enc.Base64.stringify(str);&#125;//解密function DecryptBase64(word)&#123; var words = CryptoJS.enc.Base64.parse(word); return words.toString(CryptoJS.enc.Utf8);&#125; 最后来验证一下 123456789101112var word = JSON.stringify(&#123; name : '张三'&#125;);console.log(Encrypt(word)); //oCUAMtH+jfKEt8e2VYci/Cz9GDXFY+tCt2ONjsKpGa0=console.log(Decrypt(Encrypt(word))); //&#123;"name":"张三"&#125;console.log(EncryptBase64(word)); //eyJuYW1lIjoi5byg5LiJIn0=console.log(DecryptBase64(EncryptBase64(word))); //&#123;"name":"张三"&#125;console.log(EncryptBase64(Encrypt(word))); //b0NVQU10SCtqZktFdDhlMlZZY2kvQ3o5R0RYRlkrdEN0Mk9OanNLcEdhMD0=console.log(Decrypt(DecryptBase64(EncryptBase64(Encrypt(word))))); //&#123;"name":"张三"&#125;]]></content>
      <categories>
        <category>插件工具</category>
      </categories>
      <tags>
        <tag>crypto</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Datatables分页]]></title>
    <url>%2F2017%2F09%2F18%2Fdatatables%E5%88%86%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;dataTables是自带有分页功能的，在设置”paging”: true之后，就可以开启前端分页。&nbsp;&nbsp;&nbsp;&nbsp;但是有一个弊端，就是只能对表格的数据进行分页，而在数据量过多时，要通过一次请求拿到所有数据显然是不现实的，这时候就需要后台进行分页，而前端通过请求页码得到单页数据，这时候要如何实现分页呢？在踩了几天的坑之后，终于实现了分页，下面来简单的总结一下。 首先来看一下后台接口的数据格式 12345678910111213//request&#123; pageNo: 1, pageSize: 10&#125;//response&#123; data: &#123; list: [……], totalCount: 100 &#125;, status: "200"&#125; 在请求时需要发送页码和每页的数据条数，接口返回的list就是需要的数据，totalCount则是数据的总数。 声明一下需要发送的数据 1234var sendData = &#123; pageNo: 1, pageSize: 10&#125;; 接下来配置一下dataTbles，使用ajax方式拿到数据 具体的配置不多介绍，需要注意的是，首先要开启服务器模式。12"serverSide" : true,"processing" : true, 之后配置一下datatable的ajax配置项，这里是直接使用jQuery的ajax方法发送的请求123456789101112131415161718192021"ajax" : function (data, callback) &#123; //data是表格数据，callback写入返回的数据 $.ajax(&#123; url : url, dataType : "json", contentType: "application/json", headers : &#123; token: token &#125;, data : JSON.stringify(sendData), type : "post", success : function (res) &#123; if(res.status == 200)&#123; callback(&#123; recordsTotal : res.data.totalCount, //返回数据的总数 recordsFiltered: res.data.totalCount, //返回数据数量不进行过滤，每次查询均视为全部结果 data : res.data.list &#125;); &#125; &#125; &#125;);&#125; 这里实现之后应该就可以实现分页了，但是还有一个问题，就是在切换页跟每页条数的时候，数据都不会发生变化，这是因为每次发送的sendData都没有变化。 最后一步，换页的实现12345678910//page切换事件$('#table').on('page.dt', function () &#123; sendData.pageNo = table.page() + 1; //获取当前page sendData.pageSize = table.page.len(); //获取当前page size&#125;);//page size切换事件$('#table').on('length.dt', function () &#123; sendData.pageNo = 1; sendData.pageSize = table.page.len();&#125;); 这样就完成了后台分页的前端实现。 最后记录下dataTables刷新数据用到的方法 1234//更改table ajax请求的参数table.settings()[0].ajax.data = sendData; //刷新表格数据table.ajax.reload();]]></content>
      <categories>
        <category>插件工具</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
        <tag>dataTables</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Require.js的使用]]></title>
    <url>%2F2017%2F08%2F14%2Frequirejs%2F</url>
    <content type="text"><![CDATA[require.js的诞生是为了解决两大问题 实现js文件的异步加载，避免网页失去响应； 管理模块之间的依赖性，便于代码的编写和维护。 引用首先，点击‘下载’require.js.这里可以采用网页底部加载的方式，或者1&lt;script src="js/require.js" defer async="true" &gt;&lt;/script&gt; async属性表明这个文件需要异步加载，避免网页失去响应。IE不支持这个属性，只支持defer，所以把defer也写上。 定义模块目录 data-main指定网页中的主模块，在require.js加载完成后加载js目录下的main.js，默认后缀为js，所以写main即可,其他模块也是按照datamain的目录js/查找 1&lt;script src="js/require.js" data-main="js/main"&gt;&lt;/script&gt; 定义baseUrl作为模块目录路径，config的使用见下文 123require.config(&#123; baseUrl: 'js&#125;) 这样的话，在页面引用时12&lt;script src="js/require.js"&gt;&lt;/script&gt;&lt;script src='js/main.js&gt;&lt;/script&gt; 主模块的写法123require(['jquery', 'underscore', 'backbone'], function ($, _, Backbone)&#123; // main.js内容&#125;); require()函数接受两个参数。第一个参数是一个数组，表示所依赖的模块，依次填入依赖的模块名，异步加载依赖模块；第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块返回的模块对象会以参数形式传入该函数，参数的顺序和加载的顺序相同，从而在回调函数内部就可以使用这些模块。 模块的加载使用require.config()方法，我们可以对模块的加载行为进行自定义。require.config()就写在主模块（main.js）的头部或者单独文件。 需要单独定义requireConfig文件时，要在main.js之前引用，或作为main的依赖模块引入 使用baseUrl和path配置模块路径1234567require.config(&#123; baseUrl: "js", paths: &#123; "jquery": "lib/jquery", "模块名": "模块路径" &#125;&#125;); path用于映射放于baseUrl下的模块名，模块路径不止可以是字符串，还可以是数组，写法如下 123456path: &#123; 'jquery': [ "lib/jquery"， "//cdn.bootcss.com/jquery/2.2.4/jquery" ]&#125; 会对数组内容按顺序加载，第一个加载失败后会加载第二个，作为备用路径 模块加载之后会立刻执行 其他配置 map1234567891011map: &#123; '*'： &#123; 'jquery': 'libs/jquery' &#125;, 'app/module1': &#123; 'jquery': 'lib/jquery1' &#125;, 'app/module2': &#123; 'jquery': 'lib/jquery2' &#125;&#125;, 使用map就可以实现，在加载不同的模块时，依赖不同版本的jquery waitSeconds下载js等待的时间，默认为7s，如果设置为0，则禁用等待超时，会一直加载 urlArgs加载文件时，在文件名后面增加额外的query参数 deps依赖模块，在加载requireConfig之后作为依赖模块加载 模块定义使用define方法定义AMD规范模块，如果一个模块不依赖其他模块，那么可以直接定义在define()函数之中 函数式定义1234567define('name'，['依赖模块']， function()&#123; return &#123; add : function (x,y)&#123; return x+y; &#125;; &#125; &#125;) 模块名可以不写，依赖模块可有可无，可以直接define(function(){}),可以返回任何值，函数方法，对象，变量 在加载依赖模块之后，使用name.add(x, y)即可调用。 定义对象12345define(&#123; name: 'zhangsan', age: 20, gender: '男'&#125;) 加载非规范模块加载不支持AMD的库,在用require()加载之前，要先用require.config()方法，定义它们的一些特征1234567891011require.config(&#123; shim: &#123; 'name': &#123; deps: ['jquery'], exports: 'obj', init: function($) &#123; return $; &#125; &#125; &#125;&#125;); name, 模块名 deps数组，依赖的模块。 exports值（输出的变量名），表明这个模块外部调用时的名称，即模块对象名； init,初始化函数，返回的对象代替exports作为模块对象 以bootstrap为例，在没有返回对象和init函数的情况下，在加载时可以直接写deps数组shim: { ‘bootstrap’: [‘jquery’]} 举个栗子123456789101112131415161718192021222324252627282930313233343536//app.jsrequire.config(&#123; baseUrl: "js", paths: &#123; "jquery": "lib/jquery", 'api': 'app/api', 'user': 'app/user' &#125;&#125;);require(['jquery', 'api'], function($, api)&#123; $('#btn').click(function()&#123; api.getUser().then(function(user)&#123; console.log(user); &#125;) &#125;)&#125;)//api.jsdefine(['jquery'], function($)&#123; return &#123; getUser: function()&#123; var def = $.deferred(); require(['user'],function(user) &#123; def.resolve(user); &#125;); return def; &#125; &#125;&#125;);//user.jsdefine(&#123; name: 'zhangsan', age: 20, gender: '男'&#125;)&lt;button id='btn'&gt;打印用户信息&lt;/button&gt;]]></content>
      <categories>
        <category>插件工具</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>require</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo引用自定义js与css]]></title>
    <url>%2F2017%2F08%2F09%2Fhexo%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%B7%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;这里以Yelee主题为例，介绍一下引用自定义的js文件和样式的写法，不同主题的目录结构大致类似 引入js在themes\yelee\source\js目录下新建js文件，之后找到themes\yelee\layout下的layout.ejs文件在其中使用script标签引入即可1&lt;script type=&apos;text/javascript&apos; src=&apos;/js/myjs.js&apos;&gt;&lt;/script&gt; 当然，在其他位置的ejs文件或者md文件中引入也可以使用 注意这里的路径为绝对路径，source下的js文件夹经过hexo渲染后在根目录下 引入自定义样式文件在themes\yelee\source\css目录下新建mycss.styl文件，之后在同目录下的style.styl底部使用引入即可1@import &quot;mycss&quot;]]></content>
      <categories>
        <category>插件工具</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS实现贪吃蛇]]></title>
    <url>%2F2017%2F08%2F03%2Fjs%E5%AE%9E%E7%8E%B0%E8%B4%AA%E5%90%83%E8%9B%87%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;使用canvas和原生js，二十行代码实现贪吃蛇小游戏 之前在csdn博客上看到的文章，感觉这个思路真的很新颖，我对代码进行了部分修改，并且添加了注释。‘原文地址’1234567891011121314151617181920212223242526272829303132333435363738&lt;canvas id="can" width="400" height="400" style="background:Black"&gt;&lt;/canvas&gt;&lt;script&gt; var sn=[42,41],dz=43,fx=1,n,ctx=document.getElementById("can").getContext("2d"); /* sn，存放蛇的数组，最左侧为蛇头，通过改变数据的方式改变位置 dz，食物，初始位置为蛇头右侧，自动触发并之后随机 fx，移动方向，初始向右 n，用来存储移动方向/下次移动的位置 */ function draw(t,c)&#123;// ctx.fillStyle=c; ctx.fillRect(t%20*20+1,~~(t/20)*20+1,18,18); /* 这里可以把canvas理解为400个20*20的小块 参数分别为x,y,width,height 18+1+1 这里相当于2px的padding */ &#125; document.onkeydown=function(e)&#123;fx= sn[1]-sn[0]==(n=[-1,-20,1,20][(e||event).keyCode-37]||fx)?fx:n&#125;; /* 键盘按下时，n=[-1,-20,1,20] 左，上，右，下 键盘和蛇移动方向一致，满足n=[-1,-20,1,20][(e||event).keyCode-37] 蛇的移动方向不变，否则按照键盘方向移动 */ !function()&#123; sn.unshift(n=sn[0]+fx); //获取到新的蛇头位置 if(sn.indexOf(n,1)&gt;0 || n&lt;0||n&gt;399 || fx==1&amp;&amp;n%20==0||fx==-1&amp;&amp;n%20==19 ) return alert("GAME OVER"); /* 触碰自身 n&lt;0 || n&gt;399 超出画布范围，即触碰上下边缘 fx==1&amp;&amp;n%20==0||fx==-1&amp;&amp;n%20==19 向右撞到右侧，向左撞到左侧 */ draw(n,"Lime");//画出蛇头 if(n==dz)&#123;//头部触碰食物时不移除尾部，随机生成食物 while(sn.indexOf(dz=~~(Math.random()*400))&gt;=0); draw(dz,"Yellow"); &#125;else draw(sn.pop(),"Black");//尾部移除并改变为黑色 setTimeout(arguments.callee,100); &#125;();//自运行函数，定时器运行自身&lt;/script&gt;]]></content>
      <categories>
        <category>实用技巧</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>canvas</tag>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo使用技巧(持续更新ing)]]></title>
    <url>%2F2017%2F08%2F03%2FHexo%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;总结了一些在搭建hexo博客方面遇到的一些问题和使用技巧 hexo命令简写hexo n “我的博客” == hexo new “我的博客” #新建文章hexo p == hexo publish #发布草稿hexo s == hexo server #本地服务器预览hexo g == hexo generate #生成hexo d == hexo deploy #部署hexo c == hexo clean #清除缓存hexo d -g #生成之后部署 设置文章摘要123以上是文章摘要&lt;!-- more --&gt;以下是内容 Yelee 中可以使用 description: “我是摘要” 分类以及多标签1234categories: htmltags: - js - css 或者1tags: [html,js,css] 插入图片 本地路径，在/source目录下新建一个img文件夹，将图片放入该文件夹下，插入图片时链接即为/img/图片名称 使用网络路径 /source为根目录，使用绝对路径时获取到的是source文件夹下的内容 上传html在/source目录下新建项目文件夹，在html头部添加123---layout: false--- 可以避免hexo的渲染，从而实现展示效果，使用 站点地址/文件夹name即可访问到 文章置顶修改hero-generator-index插件，在文件:node_modules/hexo-generator-index/lib/generator.js内添加代码：1234567891011121314posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排&#125;); 注意添加到return之前 使用top值对文章进行排序，在文章中添加top值即可，数值越大文章越靠前，如下123456---title: Hexo文章置顶categories: 插件工具tags: hexotop: 100--- 修改字体大小打开\themes\yelee\source\css\ _variables\base.styl文件，将$font-size-base改成16px，如下所示：1$font-size-base = 16px 自定义鼠标样式打开themes/yelee/source/css/_custom/custom.styl,在里面写下如下代码1234567// 鼠标样式 * &#123; cursor: url("http://om8u46rmb.bkt.clouddn.com/sword2.ico"),auto!important &#125; :active &#123; cursor: url("http://om8u46rmb.bkt.clouddn.com/sword1.ico"),auto!important &#125; 这里的url必须是ico格式 开启qq临时对话添加链接1&apos;http://wpa.qq.com/msgrd?v=3&amp;uin=1042625709&amp;site=qq&amp;menu=yes&apos; PC端和手机QQ都适用 代码块写法之前在用markdown写代码块的时候一直用的三个点包裹代码的形式，后来发现这么写的hexo中代码不会高亮纠正写法，在写代码块的时候，要加上对应的代码类型 持续更新ing]]></content>
      <categories>
        <category>实用技巧</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客畅言评论支持]]></title>
    <url>%2F2017%2F08%2F03%2FHexo%E5%8D%9A%E5%AE%A2%E7%95%85%E8%A8%80%E8%AF%84%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;由于多说和网易云跟帖的关闭，很多博客的评论系统受到了影响，这里通过使用Yelee主题举例说明将多说评论替换为畅言的步骤，以及畅言评论的设置问题。 代码安装1.修改文件 \themes\yelee\layout\_partial\comments\duoshuo.ejs 为如下内容，并重命名为 changyan.ejs。123456789&lt;!--PC和WAP自适应版--&gt;&lt;div id="SOHUCS" &gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; (function()&#123; var appid = '&lt;%=appid%&gt;'; var conf = '&lt;%=conf%&gt;'; var width = window.innerWidth || document.documentElement.clientWidth; if (width &lt; 960) &#123; window.document.write('&lt;script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="//changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&amp;conf=' + conf + '"&gt;&lt;\/script&gt;'); &#125; else &#123; var loadJs=function(d,a)&#123;var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function")&#123;if(window.attachEvent)&#123;b.onreadystatechange=function()&#123;var e=b.readyState;if(e==="loaded"||e==="complete")&#123;b.onreadystatechange=null;a()&#125;&#125;&#125;else&#123;b.onload=a&#125;&#125;c.appendChild(b)&#125;;loadJs("//changyan.sohu.com/upload/changyan.js",function()&#123;window.changyan.api.config(&#123;appid:appid,conf:conf&#125;)&#125;); &#125; &#125;)(); &lt;/script&gt; 这一部分是畅言安装的通用代码，在html中插入这段代码即可加入评论框。没有多说的主题可以直接添加changyan.ejs，或者修改主题支持的评论，下同。 2.修改 \themes\yelee\layout\_partial\article.ejs ，把原来多说位置的代码改为：12345678&lt;% if (!index &amp;&amp; post.comments)&#123; %&gt; &lt;% if (theme.changyan.on) &#123; %&gt; &lt;%- partial('comments/changyan', &#123; appid: theme.changyan.appid, conf: theme.changyan.conf &#125;) %&gt; &lt;% &#125; %&gt;&lt;% &#125; %&gt; 对于畅言实验室中的拓展功能，比如表情评论，打赏等功能，同样将代码添加到这部分就行，以表情评论为例 123456&lt;% if (!index &amp;&amp; post.comments)&#123; %&gt; &lt;% if (theme.changyan.on) &#123; %&gt; &lt;div id="cyEmoji" role="cylabs" data-use="emoji"&gt;&lt;/div&gt; &lt;% &#125; %&gt;&lt;% &#125; %&gt;&lt;script type="text/javascript" charset="utf-8" src="https://changyan.sohu.com/js/changyan.labs.https.js?appid=xxxxxx"&gt;&lt;/script&gt; 3.修改样式文件 \themes\yelee\source\css\_partial\main.styl ，查找 duoshou，替换为如下样式：1234#SOHUCS &#123; padding: 0 40px !important; width: inherit !important;&#125; 4.修改样式文件 \themes\yelee\source\css\_partial\mobile.styl ，查找 duoshou，替换为如下样式：123#SOHUCS &#123; padding: 0 13px;&#125; 5.将theme的 _config.yml 中 duoshuo 的部分修改为：1234changyan: on: on appid: conf: 这里的appid和conf是在畅言的后台获取，见下文。 畅言设置1.点击访问畅言官网并注册畅言 没有备案的域名可以找一个已备案域名提交审核，将自己的域名添加到域名白名单即可。 2.注册成功后进入到后台页面分别写入appid和conf即可。 3.在后台的设置选项中，可以对主题样式和评论进行设置。]]></content>
      <categories>
        <category>插件工具</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>yelee</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS常用尺寸和坐标]]></title>
    <url>%2F2017%2F08%2F01%2Fjs%E5%B0%BA%E5%AF%B8%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;js在获取宽高,距离以及坐标上有很多不同的方式，在这里对常用的方式进行一下汇总先放一张图 元素大小 width和height可以获取元素行内样式style的大小 width()和height()可以获取元素实际大小 clientWidth和clientHeight可以获取元素可视区的大小，可以得到元素内容及内边距所占据的空间大小。border,margin无效，padding生效，有滚动条的话会减去滚动条，只考虑可视区域本身。 offsetWidth和offsetHeight返回元素的实际大小，包含边框，内边距和滚动条，即border，padding均生效，有无滚动条不影响，margin不生效。 scrollWidth和scrollHeight可以获取滚动内容(可见内容)的元素大小，即overflow部分本身的高度。margin无效，padding和滚动条生效，Firefox和Opera中border生效， IE、Chrome和Safari中不生效。元素周边距离 clientLeft和clientTop获取边框大小可以获取元素左边框和上边框的值 offsetLeft和offsetTop可以获取当前元素相对于父元素的位置 scrollTop()和scrollLeft()获取和整个滚动区域顶部和左侧的距离 offset()获取匹配元素在当前视口的相对偏移，返回的对象包含两个整型属性：top 和 left position()获取匹配元素相对父元素的偏移，返回类型同上 document.body clientWidth和clientHeight元素可视区域尺寸 offsetWidth和offsetHeight跟一般元素的计算方式一样，这里是body元素 scrollWidth和scrollHeight有滚动时，大于window视窗可见尺寸，包含整个滚动区域 window innerWidth和innerHeight窗口中文档显示区域的尺寸，不包括边框，滚动条和菜单栏等部分所占尺寸，该属性可读可写。 outerWidth和outerHeight窗口本身的尺寸，包含边框，滚动条，菜单栏等尺寸，该属性可读可写。 screenTop和screenLeft网页正文部分的上方和左侧 screen.width和screen.height屏幕分辨率的宽高 screen.availWidth和screen.availHeight屏幕可用工作区宽高 坐标 e.pageX相对整个页面的坐标 e.layerX相对当前坐标系的实际大小的坐标 e.offsetX相对当前坐标系的实际大小的坐标 e.clientX相对当前坐标系的可视区域的坐标 e.screenX相对于屏幕的水平坐标。 touch ev.touches[0].pageXstart/move事件获取坐标 ev.changedTouches[0].pageXend事件获取坐标]]></content>
      <categories>
        <category>学习笔记</category>
        <category>实用技巧</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm常用命令]]></title>
    <url>%2F2017%2F08%2F01%2Fnpm%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;npm是node的包管理工具，在前端开发中起到了不可忽视的作用，这里对npm的常用命令进行了汇总安装nodejs的依赖包1npm install &lt;name&gt; 例如npm install express 就会默认安装express的最新版本，也可以通过在后面加版本号的方式安装指定版本，如npm install express@3.0.6 将包安装到全局环境中1npm install &lt;name&gt; -g 但是代码中，直接通过require()的方式是没有办法调用全局安装的包的。全局的安装是供命令行使用的，就好像全局安装了vmarket后，就可以在命令行中直接运行vm命令。 安装的同时，将信息写入package.json中1npm install &lt;name&gt; --save 项目路径中如果有package.json文件时，直接使用npm install方法就可以根据dependencies配置安装所有的依赖包这样代码提交到github时，就不用提交node_modules这个文件夹了。 创建package.json文件1npm init 移除1npm remove &lt;name&gt; 更新1npm update &lt;name&gt; 列出当前安装的所有包1npm ls 查看当前包的安装路径1npm root 查看全局的包的安装路径1npm root -g 帮助1npm help 如果要单独查看install命令的帮助，可以使用的npm help install]]></content>
      <categories>
        <category>插件工具</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular学习笔记:通信方式]]></title>
    <url>%2F2017%2F07%2F28%2Fangular%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;日常开发中，难免会有不同作用域之间的数据需求。对于controller之间通信有不同的方式可以做到。 用 Angular 进行开发，基本上都会遇到 Controller 之间通信的问题，本文对此进行一个总结。 一.$rootscope通过$rootscope定义的全局变量, 在各个controller里面都可以显示，也都可以修改。 二.作用域继承在controller的父子关系中，子controller可以继承到父级所有的$scope数据，子级中再声明时，会覆盖父级同名属性，只适用于父级向子级通信，而无法向上传递数据。 三.$watch 父作用域监视子作用域123456.controller("Parent", function($scope)&#123; $scope.VM = &#123;a: "a", b: "b"&#125;; $scope.$watch("VM.a", function(newVal, oldVal)&#123; // react &#125;);&#125; 子作用域监视父作用域12345.controller("child", function($scope)&#123; $scope.$parent.$watch($scope.VM.a, function()&#123; //react &#125;);&#125; 四.消息机制$on、$emit和$broadcast使得event、data在controller之间的传递变的简单。$emit只能向parent controller传递event与data$broadcast只能向child controller传递event与data$on用于接收event与data1234567891011$scope.$broadcast('to-child', 'child');$scope.$emit('to-parent', 'parent'); //事件名，事件对象父级中$scope.$on('to-parent', function(event,data) &#123; console.log('ParentCtrl', data); //父级能得到$emit发送的parent&#125;);子级中$scope.$on('to-child', function(event,data) &#123; console.log('ChildCtrl', data); //子级能得到$broadcast发送的child&#125;); 使用$rootscope可以接受到所有$emit的数据 五.专用service1234567891011myApp.factory('myService', function () &#123; return &#123; message: "I'm data from a service" &#125;;&#125;); function FirstCtrl($scope, Data) &#123; $scope.data = myService.message;&#125; function SecondCtrl($scope, Data) &#123; $scope.data = myService.message;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular学习笔记:$watch]]></title>
    <url>%2F2017%2F07%2F25%2Fangular%24watch%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;当angular数据模型发生变化时，我们需要如果需要根据他的变化触发其他的事件。$watch是一个scope函数，用于监听模型变化，当你的模型部分发生变化时它会通知你。 &nbsp;&nbsp;&nbsp;&nbsp;$watch(watchObj, callback, objectEquality); 参数说明： watchObj：监听的对象，它可以是一个angular表达式如’name’,或函数如function(){return $scope.name}。 callback:当watchExpression变化时会被调用的函数或者表达式,它接收3个参数：newValue(新值), oldValue(旧值), scope(作用域的引用) objectEquality：是否深度监听，如果设置为true,它告诉Angular检查所监控的对象中每一个属性的变化. 如果你希望监控数组的个别元素或者对象的属性而不是一个普通的值, 那么你应该使用它 $watch()执行时会先调用一次传入的回调，可以认为是初始化。 监听方式监听model是否发生了变化，注意这里的watch提供三种api监听 scope.$watch(watchExpression, listener)只监听对应的值或者reference是否变化，如果变化就触发注册的回调函数（也就是那个listener） scope.$watchCollection(watchExpression, listener)监听对应的值或者reference以及集合里是否发生变化（例如集合增加或者减少，但是不包括集合里面的值变化） scope.$watch (watchExpression, listener, true)监听对应的值或者reference以及集合里是否发生变化并且还包括里面的值是否发生变化，下图可以比较清晰的看出其中的区别 举个栗子:123456789html:&lt;input type="text" ng-model='num'&gt;&lt;span&gt;当前折扣为&#123;&#123;msg&#125;&#125;&lt;/span&gt;js:$scope.$watch('num',function(newNum)&#123; if(newNum &gt; 100)&#123; $scope.msg = '8折' &#125;&#125;) 监听num，当num大于100时，msg为8折]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular学习笔记:表单验证]]></title>
    <url>%2F2017%2F07%2F19%2Fangular%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;前端数据校验的意义在于改善用户体验，用户不用等到將数据提交到服务器后才知道哪些数据是不合法的。使用angular对表单元素进行校验是相当方便的，我们来看一下可以在input元素上使用的所有校验选项,可以验证必填项，长度和正则匹配等. 属性值验证 必填项验证某个表单输入是否已填写，只要在输入字段元素上添加HTML5标记required即可： 1&lt;input type="text" required /&gt; 最小长度验证表单输入的文本长度是否大于某个最小值，在输入字段上使用指令ng-minleng= “{number}”： 1&lt;input type="text" ng-minlength="5" /&gt; 最大长度验证表单输入的文本长度是否小于或等于某个最大值，在输入字段上使用指令ng-maxlength=”{number}”： 1&lt;input type="text" ng-maxlength="20" /&gt; 模式匹配使用ng-pattern=”/PATTERN/“来确保输入能够匹配指定的正则表达式： 1&lt;input type="text" ng-pattern="/[a-zA-Z]/" /&gt; PS： 使用input的type属性，可以对email，number，url进行验证 form中添加novalidate属性,使表单自带的验证无效 表单验证 未修改过的表单布尔值属性，表示用户是否修改了表单。如果为ture，表示没有修改过；false表示修改过： 1formName.inputFieldName.$pristine; 修改的表单布尔型属性，当且仅当用户实际已经修改的表单。不管表单是否通过验证： 1formName.inputFieldName.$dirty 经过验证的表单布尔型属性，它指示表单是否通过验证。如果表单当前通过验证，他将为true： 1formName.inputFieldName.$valid 未通过验证的表单 1formName.inputFieldName.$invalid PS：ng-disabled=”formName.inputFieldName.$invalid” 表单验证不通过时按钮失效 举个栗子:在表单验证出错时，可以通过ng-show显示报错信息123456&lt;form name="userForm"&gt; &lt;input type="text" name="username" ng-model="user.username" ng-minlength="3" ng-maxlength="8" required&gt; &lt;p ng-show="userForm.username.$error.minlength"&gt;Username is too short.&lt;/p&gt; &lt;p ng-show="userForm.username.$error.maxlength"&gt;Username is too long.&lt;/p&gt; &lt;p ng-show="userForm.username.$error.required"&gt;Your username is required.&lt;/p&gt;&lt;/form&gt; 也可以使用ng-message12345&lt;div ng-messages="userForm.name.$error"&gt; &lt;p ng-message="minlength"&gt;Username is too short.&lt;/p&gt; &lt;p ng-message="maxlength"&gt;Username is too long.&lt;/p&gt; &lt;p ng-message="required"&gt;Your username is required.&lt;/p&gt;&lt;/div&gt;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>angular</tag>
      </tags>
  </entry>
</search>
